<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from chpp.texi on 30 April 1998 -->

<TITLE>CHPP Tutorial and Reference</TITLE>
</HEAD>
<BODY>
<H1>chpp</H1>
<H2>Tutorial (in spe) and Reference</H2>
<H2>last updated 21 April 1998 for version 0.3</H2>
<ADDRESS>Mark Probst (<A HREF="mailto:schani@unix.cslab.tuwien.ac.at">schani@unix.cslab.tuwien.ac.at</A>)</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="chpp.html#SEC1">Introduction</A>
<UL>
<LI><A NAME="TOC2" HREF="chpp.html#SEC2">What <CODE>chpp</CODE> stands for</A>
<LI><A NAME="TOC3" HREF="chpp.html#SEC3">Uses for <CODE>chpp</CODE></A>
<LI><A NAME="TOC4" HREF="chpp.html#SEC4">What <CODE>chpp</CODE> should not be used for</A>
<LI><A NAME="TOC5" HREF="chpp.html#SEC5">Planned but not yet Implemented Features</A>
<LI><A NAME="TOC6" HREF="chpp.html#SEC6">Obtaining <CODE>chpp</CODE></A>
<LI><A NAME="TOC7" HREF="chpp.html#SEC7">The History of <CODE>chpp</CODE></A>
<LI><A NAME="TOC8" HREF="chpp.html#SEC8">Problems and Known Bugs</A>
<LI><A NAME="TOC9" HREF="chpp.html#SEC9">Reporting Bugs</A>
<LI><A NAME="TOC10" HREF="chpp.html#SEC10">Licence and Warranty</A>
<LI><A NAME="TOC11" HREF="chpp.html#SEC11">The Authors</A>
<LI><A NAME="TOC12" HREF="chpp.html#SEC12">Acknowledgements</A>
</UL>
<LI><A NAME="TOC13" HREF="chpp.html#SEC13">A Guided Tour through <CODE>chpp</CODE></A>
<LI><A NAME="TOC14" HREF="chpp.html#SEC14">Examples</A>
<UL>
<LI><A NAME="TOC15" HREF="chpp.html#SEC15">Song Lyrics</A>
<LI><A NAME="TOC16" HREF="chpp.html#SEC16">Web Site</A>
<LI><A NAME="TOC17" HREF="chpp.html#SEC17">Tautogen</A>
</UL>
<LI><A NAME="TOC18" HREF="chpp.html#SEC18">Invoking <CODE>chpp</CODE></A>
<LI><A NAME="TOC19" HREF="chpp.html#SEC19">Language Reference</A>
<UL>
<LI><A NAME="TOC20" HREF="chpp.html#SEC20">Commands</A>
<UL>
<LI><A NAME="TOC21" HREF="chpp.html#SEC21">Comments</A>
<LI><A NAME="TOC22" HREF="chpp.html#SEC22">Command Reference</A>
</UL>
<LI><A NAME="TOC23" HREF="chpp.html#SEC23">The Meta-Char</A>
<LI><A NAME="TOC24" HREF="chpp.html#SEC24">Data Types</A>
<UL>
<LI><A NAME="TOC25" HREF="chpp.html#SEC25">Scalars</A>
<LI><A NAME="TOC26" HREF="chpp.html#SEC26">Lists</A>
<LI><A NAME="TOC27" HREF="chpp.html#SEC27">Hashes</A>
<LI><A NAME="TOC28" HREF="chpp.html#SEC28">Closures</A>
</UL>
<LI><A NAME="TOC29" HREF="chpp.html#SEC29">Variables</A>
<UL>
<LI><A NAME="TOC30" HREF="chpp.html#SEC30">Accessing Variables</A>
<LI><A NAME="TOC31" HREF="chpp.html#SEC31">List and Hash Subscription</A>
<LI><A NAME="TOC32" HREF="chpp.html#SEC32">Copies and References</A>
<LI><A NAME="TOC33" HREF="chpp.html#SEC33">Macro Invocation</A>
<LI><A NAME="TOC34" HREF="chpp.html#SEC34">Subscribing Non-Variables</A>
<LI><A NAME="TOC35" HREF="chpp.html#SEC35">Assignment</A>
<LI><A NAME="TOC36" HREF="chpp.html#SEC36">Scoping Rules</A>
</UL>
<LI><A NAME="TOC37" HREF="chpp.html#SEC37">Arithmetic Expansion</A>
<LI><A NAME="TOC38" HREF="chpp.html#SEC38">Quotation</A>
<LI><A NAME="TOC39" HREF="chpp.html#SEC39">Explicit Evaluation</A>
</UL>
<LI><A NAME="TOC40" HREF="chpp.html#SEC40">Extending <CODE>chpp</CODE></A>
<LI><A NAME="TOC41" HREF="chpp.html#SEC41">Special Forms</A>
<LI><A NAME="TOC42" HREF="chpp.html#SEC42">Macros</A>
<UL>
<LI><A NAME="TOC43" HREF="chpp.html#SEC43">List Operations</A>
<LI><A NAME="TOC44" HREF="chpp.html#SEC44">Hash Operations</A>
<LI><A NAME="TOC45" HREF="chpp.html#SEC45">File Operations</A>
<LI><A NAME="TOC46" HREF="chpp.html#SEC46">String Operations</A>
<LI><A NAME="TOC47" HREF="chpp.html#SEC47">Miscellaneous</A>
</UL>
<LI><A NAME="TOC48" HREF="chpp.html#SEC48">Internal Variables</A>
<LI><A NAME="TOC49" HREF="chpp.html#SEC49">Packages</A>
<UL>
<LI><A NAME="TOC50" HREF="chpp.html#SEC50"><TT>`files.chh'</TT></A>
<LI><A NAME="TOC51" HREF="chpp.html#SEC51"><TT>`strings.chh'</TT></A>
<LI><A NAME="TOC52" HREF="chpp.html#SEC52"><TT>`list.chh'</TT></A>
<LI><A NAME="TOC53" HREF="chpp.html#SEC53"><TT>`time.chh'</TT></A>
<LI><A NAME="TOC54" HREF="chpp.html#SEC54"><TT>`sql.chh'</TT></A>
<LI><A NAME="TOC55" HREF="chpp.html#SEC55"><TT>`cgi.chh'</TT></A>
</UL>
<LI><A NAME="TOC56" HREF="chpp.html#SEC56">Macro Index</A>
</UL>
<P><HR><P>


<H1><A NAME="SEC1" HREF="chpp.html#TOC1">Introduction</A></H1>

<P>
<CODE>chpp</CODE> is a preprocessor. Therefore, its main purpose is to modify
input text by including other input files and by macro expansion.
Programs performing these tasks already exist, among them the popular C
Preprocessor (<CODE>cpp</CODE>) and <CODE>m4</CODE>, which have proven to be
convenient and valuable tools suitable for a variety of tasks. The
motivation for <CODE>chpp</CODE> is thus questionable.

</P>
<P>
What distinguishes <CODE>chpp</CODE> from at least the two programs mentioned
above are mainly two features:

</P>

<UL>
<LI>

<CODE>chpp</CODE> is non-intrusive. This means that you can take your
favourite text and it is very unlikely that it will be changed when
piped through <CODE>chpp</CODE>. Due to this feature it is pretty easy to
start using <CODE>chpp</CODE> since you can just start writing your text and
need not concern yourself with <CODE>chpp</CODE> sitting in the background
changing it for no obvious reason.

<LI>

<CODE>chpp</CODE> is not just a package for performing simple macro expansion,
but can indeed be considered a full-fledged programming language. Most
importantly, it provides support for complex data structures, namely
lists and hashes (associative arrays), which can be nested arbitrarily.
</UL>

<P>
<CODE>chpp</CODE> consists of two parts which could, in some sense, be
regarded as two separate passes over the input file. This is not
entirely true, though, since the two parts are intertwined and cannot be
separated. The first part, which performs command processing, is similar
to what <CODE>cpp</CODE> does.  It allows the inclusion of other files, simple
macro definitions and conditional inclusion and exclusion of parts of
the input. The second part does macro processing and is the actual
workhorse and core of <CODE>chpp</CODE>.

</P>
<P>
Although macro processing on its own could do anything that can be
accomplished with commands, the latter are not only easier to use but
also easier to read and therefore improve clarity.

</P>



<H2><A NAME="SEC2" HREF="chpp.html#TOC2">What <CODE>chpp</CODE> stands for</A></H2>

<P>
<CODE>chpp</CODE> does <STRONG>not</STRONG> stand for Chakotay Preprocessor.

</P>


<H2><A NAME="SEC3" HREF="chpp.html#TOC3">Uses for <CODE>chpp</CODE></A></H2>

<P>
<CODE>chpp</CODE> can be used very well as

</P>

<UL>
<LI>

a preprocessor for HTML (see section <A HREF="chpp.html#SEC16">Web Site</A>). This was, by the way, our
original motivation for <CODE>chpp</CODE> (see section <A HREF="chpp.html#SEC7">The History of <CODE>chpp</CODE></A>).

<LI>

a CGI scripting language. <CODE>chpp</CODE> will become even more attractive
for this kind of application when the planned database interface
(see section <A HREF="chpp.html#SEC5">Planned but not yet Implemented Features</A>) is available.

<LI>

a generator of Quake(tm) configuration files.

<LI>

a producer of funny sentences (see section <A HREF="chpp.html#SEC17">Tautogen</A>).

<LI>

and a lot more...
</UL>



<H2><A NAME="SEC4" HREF="chpp.html#TOC4">What <CODE>chpp</CODE> should not be used for</A></H2>

<P>
<CODE>chpp</CODE> should, due to its nature, not be used for

</P>

<UL>
<LI>

interactive applications.

<LI>

applications where text output is only a secondary function.

<LI>

applications which require speed. Unfortunately, <CODE>chpp</CODE> is not a
fast program. However, this may change in the future
(see section <A HREF="chpp.html#SEC5">Planned but not yet Implemented Features</A>).
</UL>



<H2><A NAME="SEC5" HREF="chpp.html#TOC5">Planned but not yet Implemented Features</A></H2>

<P>
We will, in some of the next releases, improve the performance of
<CODE>chpp</CODE> by yet another factor of two for typical applications.

</P>
<P>
It will be possible to write new built-in macros in C, which <CODE>chpp</CODE>
will load dynamically at run-time (see section <A HREF="chpp.html#SEC40">Extending <CODE>chpp</CODE></A>).

</P>
<P>
We would also like to add a few extension packages to <CODE>chpp</CODE>, which
will make it more suitable for and easier to apply to various
applications, most notably CGI scripting, HTML generation and database
interfacing.

</P>


<H2><A NAME="SEC6" HREF="chpp.html#TOC6">Obtaining <CODE>chpp</CODE></A></H2>

<P>
<CODE>chpp</CODE> is available for free download on the world-wide-web. Point
your web-browser at @url{http://chakotay.ml.org/} (or
@url{http://chakotay.ml.org/chpp/} if you are using an ancient
browser). From there you can download the latest version of <CODE>chpp</CODE>.

</P>


<H2><A NAME="SEC7" HREF="chpp.html#TOC7">The History of <CODE>chpp</CODE></A></H2>

<P>
Not much here, yet.

</P>


<H2><A NAME="SEC8" HREF="chpp.html#TOC8">Problems and Known Bugs</A></H2>

<P>
<CODE>chpp</CODE> is far from error-free in its current version. It works
quite reliably now when not stressed too far, though. The biggest
problem is currently that <CODE>chpp</CODE>'s error handling is
insufficient. <CODE>chpp</CODE> does not report some errors, while others
cause it to crash or to hang up in an endless loop. We do, of course,
plan to change this in the future.

</P>


<H2><A NAME="SEC9" HREF="chpp.html#TOC9">Reporting Bugs</A></H2>

<P>
Before you tell us about a bug, please check that you are using the
latest version of <CODE>chpp</CODE> (see section <A HREF="chpp.html#SEC6">Obtaining <CODE>chpp</CODE></A>). If this is not
the case, please upgrade and try again.

</P>
<P>
Please do not report bugs that concern <CODE>chpp</CODE>'s error handling. We
know that it is unreliable and buggy and we will change that. You
should, however, report any incident where <CODE>chpp</CODE> does anything
wrong with a script which you believe is correct. In such a case, please
write us an email containing the script that causes <CODE>chpp</CODE> to fail
and any additional files that your script needs. Better yet, try to
narrow the bug down to the smallest script possible. Do also include
information on the configuration you ran <CODE>chpp</CODE> on, especially if
the bug only happens to show up with this configuration. The email
address you should send your bug-report to is
@email{chpp@unix.cslab.tuwien.ac.at}.

</P>


<H2><A NAME="SEC10" HREF="chpp.html#TOC10">Licence and Warranty</A></H2>

<P>
<CODE>chpp</CODE> is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

</P>
<P>
<CODE>chpp</CODE> is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

</P>
<P>
You should have received a copy of the GNU General Public License
along with <CODE>chpp</CODE>; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

</P>


<H2><A NAME="SEC11" HREF="chpp.html#TOC11">The Authors</A></H2>

<P>
<CODE>chpp</CODE> was designed and implemented by Heinz Deinhart
(@email{heinz@unix.cslab.tuwien.ac.at}) and Mark Probst
(@email{schani@unix.cslab.tuwien.ac.at}). Check out the <CODE>chpp</CODE>
homepage (see section <A HREF="chpp.html#SEC6">Obtaining <CODE>chpp</CODE></A>) for more information.

</P>


<H2><A NAME="SEC12" HREF="chpp.html#TOC12">Acknowledgements</A></H2>

<P>
Our thanks go to Tatjana Svizensky for proofreading this manual and to
Herbert P@"otzl for donating the hash-table functions, which we were too
lazy, erm, too busy to implement, and for not reading the examples
chapter of this document.

</P>



<H1><A NAME="SEC13" HREF="chpp.html#TOC13">A Guided Tour through <CODE>chpp</CODE></A></H1>



<H1><A NAME="SEC14" HREF="chpp.html#TOC14">Examples</A></H1>

<P>
This chapter gives a few more practical examples of the use of
<CODE>chpp</CODE>, illustrating a few of its many possible applications.

</P>



<H2><A NAME="SEC15" HREF="chpp.html#TOC15">Song Lyrics</A></H2>

<P>
Let us assume you have gathered a collection of song lyrics by various
performers as text files. You wish to generate not only HTML files for
all the songs but also an index page for each performer which contains,
sorted by album, hyperlinks to all the song HTML files.

</P>
<P>
The song files you have collected all look like this:

</P>

<PRE>
Gloria

I try to sing this song.
I try to stand up.
But I can't find my feet.
I try, I try to speak up.
But only in you I'm complete.
...
</PRE>

<P>
Furthermore, assume you have created a directory for each performer
containing a directory for each album where the song files reside. The
names of the directories not necessarily match the corresponding
performer's name or the album's, as these often contain spaces, which
are uncommon in file names. The same applies to the song file
names. Thus, our first task is to somehow associate the names of the
performers, albums and songs with the song files. We have a bonus for
the song names since these are included in the song files themselves (in
the first line). For simplicity we will include this information in the
files themselves, namely as HTML comments containing assignments in
<CODE>chpp</CODE> syntax. To modify the files, we will use the following
<CODE>chpp</CODE> script:

</P>

<PRE>
#include files.chh
%&#60;file=%fopen(%SONGFILENAME)&#62;\
%&#60;songname=%sremovews(%fgets(%file))&#62;\
&#60;!-- %%&#60;song=%songname&#62;%%&#60;album=%ALBUM&#62;%%&#60;perf=%PERF&#62; --&#62;
%frest(%file)\
%fclose(%file)\
</PRE>

<P>
The variables <CODE>SONGFILENAME</CODE>, <CODE>ALBUM</CODE> and <CODE>PERF</CODE> must be
set via the command-line. We can now convert all files in one album with
the following shell-command (assuming we are in the correct directory
and that all song files have the extension <TT>`.txt'</TT>):

</P>

<PRE>
$ pwd
/home/schani/lyrics/u2/october
$ for fn in *.txt ; do
&#62;   chpp -DSONGFILENAME=$fn -DALBUM='October' \
&#62;        -DPERF='U2' ../../convert.ch &#62;../$fn
&#62; done
</PRE>

<P>
Note that we have generated the modified files in the performer's
directory. After we have done this for all albums, we can delete the
album directories. The song files now look like this:

</P>

<PRE>
&#60;!-- %&#60;song=Gloria&#62;%&#60;album=October&#62;%&#60;perf=U2&#62; --&#62;

I try to sing this song.
I try to stand up.
But I can't find my feet.
I try, I try to speak up.
But only in you I'm complete.
...
</PRE>

<P>
We will now generate HTML files for the songs. For simplicity, we will
generate a simple HTML file which contains the song text in a
<CODE>&#60;pre&#62;</CODE> block:

</P>

<PRE>
#include files.chh
%&#60;file=%fopen(%SONGFILENAME)&#62;%void(%{%fgets(%file)})\
\
&#60;html&#62; &#60;head&#62;
&#60;title&#62;%song - %album - %perf&#60;/title&#62;
&#60;/head&#62; &#60;body&#62;
&#60;h1&#62;%song&#60;/h1&#62;
&#60;pre&#62;
%frest(%file)\
&#60;/pre&#62;
&#60;/body&#62;
&#60;/html&#62;
%fclose(file)\
</PRE>

<P>
Since the information about the song title, album and performer is coded
as <CODE>chpp</CODE> code in the first line, we can obtain it by just
evaluating it and ignoring its result. With this script we can now
generate HTML files for all songs of one performer with the following
<CODE>bash</CODE> command:

</P>

<PRE>
$ pwd
/home/schani/lyrics/u2
$ for fn in *.txt ; do
&#62;   chpp -DSONGFILENAME=$fn ../template.ch &#62;${fn%.txt}.html
&#62; done
</PRE>

<P>
Finally, we need to generate an index file for each performer containing
hyperlinks to all songs. This file is generated by the following
<CODE>chpp</CODE> script:

</P>

<PRE>
#include files.chh
%&#60;albums=%hash()&#62;\
%&#60;file=%fpipe(/bin/sh,-c,ls *.txt)&#62;\
%foreach(songfilename,%ssplit(%'[ \n]+',%sremovews(%frest(file))),
    %&#60;songfile=%fopen(%songfilename)&#62;\
    %void(%{%fgets(%songfile)})\
    %fclose(%songfile)\
    %&#60;regs=%list()&#62;%void(%smatch(%'(.*)\\.',%songfilename,%&#38;regs))\
    %&#60;htmlfile=%regs[1].html&#62;\
    %if(%hcontains(%albums,%album),
        %&#60;albums{%album}{%song}=%htmlfile&#62;
    ,
        %&#60;albums{%album}=%hash(%song,%htmlfile)&#62;
    )\
)\
%fclose(file)\
\
&#60;html&#62;
&#60;head&#62;
&#60;title&#62;%perf&#60;/title&#62;
&#60;/head&#62;
&#60;body&#62;
&#60;h1&#62;%perf&#60;/h1&#62;
%foreach(album,%lsort(%hkeys(%albums)),\
    &#60;h2&#62;%album&#60;/h2&#62;%'\n'&#60;blockquote&#62;%'\n'\
    %foreach(song,%lsort(%hkeys(%albums{%album})),\
        &#60;p&#62;&#60;a href="%albums{%album}{%song}"&#62;%song&#60;/a&#62;%'\n'\
    )\
    &#60;/blockquote&#62;%'\n'\
)\
&#60;/body&#62;
&#60;/html&#62;
</PRE>

<P>
The first part of the file gets all information about the songs in the
current directory. It generates an entry in the hash <CODE>%albums</CODE> for
each album, which in turn is a hash containing all names of the HTML
files indexed by the song names. The second part just iterates through
this table, producing an <CODE>&#60;h2&#62;</CODE> for each album and an anchor for
each song within.

</P>


<H2><A NAME="SEC16" HREF="chpp.html#TOC16">Web Site</A></H2>

<P>
Suppose you were to create a web-site with three main pages: News, Tips
and Tricks. Each of these pages should have a layout similar to this:

</P>

<PRE>
  N   N EEEE W     W  SSS         News
  NN  N E    W     W S
  N N N EEE   W W W   SSS         _Tips_
  N  NN E     W W W      S
  N   N EEEE   W W    SSS         _Tricks_

--------------------------------------------

This is good news!

--------------------------------------------

         News | _Tips_ | _Tricks_
</PRE>

<P>
The header consists of a big graphic banner denoting the title of this
particular page. On the right side of the banner are three little
graphics, each standing for one of the pages. Two of them lead to the
other two pages, whereas the one for the actual page is not functional
and grayed out.

</P>
<P>
The footer consists of a textual link bar with two active links and one
'inactive link' (normal text) for the actual page.

</P>
<P>
Although these three pages are easy to implement with conventional
methods, this becomes increasingly difficult when there are more pages
or even hierarchical structures of pages. Therefore, we will use this as
an example of how to easily create HTML pages with <CODE>chpp</CODE>, leaving
more sophisticated designs to the gentle reader.

</P>
<P>
Ideally, we would like, say, the news source file (which we name
<TT>`news.csml'</TT>), as rendered above, to look like this:

</P>

<PRE>
#include header.chml

This is good news!

#include footer.chml
</PRE>

<P>
This way, we need not be concerned with the design of the header and
footer when we work on the pages and we can easily modify the header and
footer in one central place, although they apply to our whole web-site.

</P>
<P>
Now we need a place where we can enter all the names of the main pages
of our web-site and associate them with their corresponding files. We
call this file <TT>`menu.chml'</TT>:

</P>

<PRE>
%addmenuentry(News,news.csml)
%addmenuentry(Tips,tips.csml)
%addmenuentry(Tricks,tricks.csml)
</PRE>

<P>
We simply assume that the generated HTML files will have the same
base-name as the sources but the extension <TT>`.html'</TT>. We furthermore
assume that for each main-page we have three additional graphics
available, namely one containing the large banner and two containing the
small icons, where one of the two is grayed out. These images have the
format JPEG, hence the extension <TT>`.jpg'</TT>. Their base-names consist
of the base-names of their main-pages followed by one of the suffixes
<TT>`_l'</TT>, <TT>`_s'</TT> and <TT>`_s_g'</TT>, where <TT>`l'</TT> denotes large,
<TT>`s'</TT> small and <TT>`g'</TT> gray.

</P>
<P>
The include-file <TT>`header.chml'</TT> fulfills two purposes: Firstly, it
must process the information of the file <TT>`menu.chml'</TT> and secondly,
it must generate the header of the HTML file. Since the latter depends
on the former, we will first focus our attention on processing the
information of <TT>`menu.chml'</TT>. Each main page will be represented by a
hash containing the keys <CODE>filename</CODE>, <CODE>name</CODE>,
<CODE>htmlfilename</CODE>, <CODE>imglarge</CODE>, <CODE>imgsmall</CODE> and
<CODE>imgsmallgray</CODE>, the meanings of which should be obvious. We will
collect all these hashes in a list named <CODE>menu</CODE>, which will contain
these hashes in the order in which they were entered in
<TT>`menu.chml'</TT>. Since <TT>`menu.chml'</TT> is already in <CODE>chpp</CODE>
syntax, all we need to do is to define a macro <CODE>addmenuentry</CODE> which
creates such a hash and appends it to the list <CODE>menu</CODE>:

</P>

<PRE>
%&#60;menu=%list()&#62;\
%define(addmenuentry,name,filename,
    %&#60;regs=%list()&#62;%void(%smatch(%'(.*)\\.csml$',%filename,%&#38;regs))\
    %&#60;basename=%regs[1]&#62;\
    %lappend(%&#38;menu,
        %hash(filename,%filename,
              name,%name,
              htmlfilename,%basename.html,
              imglarge,%&#60;basename&#62;_l.jpg,
              imgsmall,%&#60;basename&#62;_s.jpg,
              imgsmallgray,%&#60;basename&#62;_s_g.jpg))
)\
</PRE>

<P>
Now we can include <TT>`menu.chml'</TT> for its side-effects:

</P>

<PRE>
%void(
#include menu.chml
)\
</PRE>

<P>
Finally, for convenience, we define a variable <CODE>thisentry</CODE> which
contains the hash that applies to the currently processed page:

</P>

<PRE>
%&#60;thisentry=%foreach(menuentry,%menu,
    %if(%equal(%menuentry{filename},%mainfilename),%menuentry))&#62;\
</PRE>

<P>
Now we are set and can generate the header of the HTML file:

</P>

<PRE>
&#60;html&#62;
&#60;head&#62;
&#60;title&#62;%thisentry{name}&#60;/title&#62;
&#60;/head&#62;
&#60;body&#62;
&#60;table&#62;
&#60;td&#62;
&#60;img src="%thisentry{imglarge}" alt="%thisentry{name}"&#62;
&#60;td&#62;
#include choicestrip.chml
&#60;/table&#62;
&#60;hr&#62;
</PRE>

<P>
The file <TT>`choicestrip.chml'</TT> generates a vertical table consisting
of the small images for the main-pages with links. It is quite simple:

</P>

<PRE>
&#60;table border=0 cellspacing=0 cellpadding=0&#62;
%foreach(menuentry,%menu,
    &#60;tr&#62;&#60;td&#62;\
    %if(%equal(%menuentry{filename},%thisentry{filename}),
        &#60;img src="%menuentry{imgsmallgray}" alt="%menuentry{name}"&#62;
    ,
        &#60;a href="%menuentry{htmlfilename}"&#62;\
        &#60;img border=0 src="%menuentry{imgsmall}" alt="%menuentry{name}"&#62;\
        &#60;/a&#62;
    )
)
&#60;/table&#62;
</PRE>

<P>
The footer is even more simple: It contains a horizontal rule and a
choice-bar:

</P>

<PRE>
&#60;hr&#62;
#include choicebar.chml
&#60;/body&#62;
&#60;/html&#62;
</PRE>

<P>
<TT>`choicebar.chml'</TT> is similar to <TT>`choicestrip.chml'</TT>:

</P>

<PRE>
#include list.chh
&#60;h5&#62;&#60;center&#62;
%&#60;barentries=%list()&#62;\
%foreach(menuentry,%menu,
    %lappend(%&#38;barentries,
        %if(%equal(%menuentry{filename},%thisentry{filename}),
            %menuentry{name}
        ,
            &#60;a href="%menuentry{htmlfilename}"&#62;%menuentry{name}&#60;/a&#62;
        )
    )
)\
%listJoin(%' | ',%barentries)
&#60;/center&#62;&#60;/h5&#62;
</PRE>

<P>
All we need now is a comfortable way to create all HTML files from the
sources. That is what makefiles are for. They have the additional
advantage that files are regenerated only if needed, i.e. when one of
the files that the file to be created depends on has changed. A makefile
for <CODE>gnumake</CODE> suitable for our simple purposes would look like
this:

</P>

<PRE>
CHFILES=header.chml footer.chml choicebar.chml choicestrip.chml

all : news.html tips.html tricks.html

%.html : %.csml
	../../macros -o $ $&#60;

news.html tricks.html tips.html : $(CHFILES)

clean :
	rm -f news.html tips.html tricks.html
</PRE>



<H2><A NAME="SEC17" HREF="chpp.html#TOC17">Tautogen</A></H2>

<P>
Suppose we have a simple context-sensitive grammar, which we want to use
to generate sentences, which is quite the opposite of parsing sentences
of that grammar. To illustrate this more clearly, let us assume we have
a file like this:

</P>

<PRE>
--sentence
$subject $verb $object.
$subject, while $gerund $object, $verb $object.
$subject watches $object $gerund $object.

--subject
$person
The $adjective $person

--object
$person

--person
Butthead
Mrs Krabappel
Charlie Brown
Mrs Robinson

--adjective
observant
naive
embarassed

--verb
kisses
kicks
envies

--gerund
holding
zapping
hugging
smashing
</PRE>

<P>
The file is separated into several categories containing so-called
productions for so-called non-terminals. The first non-terminal is
called the start non-terminal, which is, in our case, <CODE>sentence</CODE>.
We start by randomly picking one of the right-hand-sides of the
productions of the start non-terminal (i.e. one of the lines following
the introduction of <CODE>sentence</CODE>). Now we repeat the following cycle
until our string contains no more placeholders (words prefixed by the
dollar sign (<CODE>$</CODE>)): Replace the first placeholder by the
right-hand-side of a randomly picked production for that placeholder.

</P>
<P>
The process could evolve like this:

</P>

<PRE>
$sentence
$subject, while $gerund $object, $verb $object.
The $adjective $person, while $gerund $object, $verb $object.
The naive $person, while $gerund $object, $verb $object.
The naive Charlie Brown, while $gerund $object, $verb $object.
The naive Charlie Brown, while hugging $object, $verb $object.
The naive Charlie Brown, while hugging $person, $verb $object.
The naive Charlie Brown, while hugging Mrs Robinson, $verb $object.
The naive Charlie Brown, while hugging Mrs Robinson, kicks $object.
The naive Charlie Brown, while hugging Mrs Robinson, kicks $person.
The naive Charlie Brown, while hugging Mrs Robinson, kicks Butthead.
</PRE>

<P>
It is easy to see that this simple algorithm even allows for recursive
grammars.

</P>
<P>
This example is not a typical application for a pre-processor. It should
rather demonstrate that <CODE>chpp</CODE> can be used very successfully for
tackling problems not within its direct field of application, i.e. that
it is suitable for more general problems.

</P>
<P>
You may have noticed that our grammar file is not in <CODE>chpp</CODE> syntax,
so we have the choice of either converting it or parsing it at
run-time. Since the former has the disadvantage of being more
complicated in usage (the grammar would have to be converted each time
it is changed) and is not easier to implement than the latter, the
choice is obvious.

</P>
<P>
The first step of our application is reading in the grammar file, which
we call <TT>`grammar'</TT>. Its content will be stored in a hash
<CODE>data</CODE>, where the keys are the names of the non-terminals and the
values are the lists of the right-hand-sides of the corresponding
productions.

</P>

<PRE>
%&#60;file=%fopen(grammar)&#62;\
%&#60;current=runaway&#62;\
%&#60;data=%hash(runaway,%list())&#62;\
%until(%feof(%file),
    %&#60;line=%sremovews(%fgets(%file))&#62;\
    %&#60;regs=%list()&#62;\
    %if(%[%smatch(%'^--([a-zA-Z0-9_]+)',%line,%&#38;regs)!=-1],
        %&#60;current=%regs[1]&#62;\
        %&#60;data{%current}=%list()&#62;\
        %if(%not(%bound(start)),%&#60;start=%current&#62;)
    ,
        %if(%line,%&#60;data{%current}[%llength(%data{%current})]=%line&#62;)
    )
)\
%fclose(%file)\
</PRE>

<P>
We then proceed to define some variables and macros. First, if the
variable <CODE>n</CODE>, which will denote the number of sentences generated,
is not defined (it could be defined on the command-line), it is set to
<CODE>10</CODE>:

</P>

<PRE>
%if(%not(%bound(n)),%&#60;n=10&#62;)\
</PRE>

<P>
The macro <CODE>some</CODE>, when called with the name of a non-terminal,
returns the right-hand-side of a random production for that
non-terminal:

</P>

<PRE>
%define(some,nt,%data{%nt}[%random(%llength(%data{%nt}))])\
</PRE>

<P>
The generation of the sentences is now a fairly trivial task:

</P>

<PRE>
#include strings.chh
%for(i,1,%n,
    %&#60;current=%some(%start)&#62;\
    %&#60;regs=%list()&#62;\
    %while(%&#60;mp=%smatch(%'\\$([a-zA-Z0-9_]+)',%current,%&#38;regs)&#62;%[mp!=-1],
        %&#60;current=%replacesubstring(%current,%mp,%slength(%regs[0]),
                                    %some(%regs[1]))&#62;
    )\
    %current%'\n\n'
)\
</PRE>



<H1><A NAME="SEC18" HREF="chpp.html#TOC18">Invoking <CODE>chpp</CODE></A></H1>

<P>
To get a quick overview of <CODE>chpp</CODE> command line syntax, just type

</P>

<PRE>
chpp --help
</PRE>

<P>
The general <CODE>chpp</CODE> syntax is

</P>

<PRE>
chpp [<VAR>option</VAR> ...] [<VAR>filename</VAR> ...]
</PRE>

<P>
<CODE>chpp</CODE> reads and processes all specified files in sequential order,
as if they were one file. If no file is specified, <CODE>chpp</CODE> reads
from standard input. Output is written to standard output if not
otherwise specified.

</P>
<P>
The following is a summary and description of all available <CODE>chpp</CODE>
options:

</P>
<DL COMPACT>

<DT><CODE>--version</CODE>
<DD>
Prints out the version number of the invoked <CODE>chpp</CODE>.

<DT><CODE>--help</CODE>
<DD>
Prints out a summary of <CODE>chpp</CODE> command line syntax.

<DT><CODE>--output <VAR>filename</VAR></CODE>
<DD>
<DT><CODE>-o <VAR>filename</VAR></CODE>
<DD>
Specifies that output should be written to file <VAR>filename</VAR>.

<DT><CODE>--include-dir <VAR>dir</VAR></CODE>
<DD>
<DT><CODE>-I <VAR>dir</VAR></CODE>
<DD>
Adds <VAR>dir</VAR> to the list of standard include directories.

<DT><CODE>-D <VAR>name</VAR>=<VAR>value</VAR></CODE>
<DD>
Defines the <CODE>chpp</CODE> variable <VAR>name</VAR> with the value <VAR>value</VAR>.

<DT><CODE>--generate-dependencies</CODE>
<DD>
<DT><CODE>-M</CODE>
<DD>
Generates a dependency list suitable for <CODE>make</CODE> like <CODE>cpp</CODE>.
</DL>



<H1><A NAME="SEC19" HREF="chpp.html#TOC19">Language Reference</A></H1>

<P>
Files processed with <CODE>chpp</CODE> are passed through two stages, which
are, however, not sequential in nature but can rather be viewed as
coroutines. The first stage processes commands
(see section <A HREF="chpp.html#SEC20">Commands</A>). Command processing is a sequential process, i.e. no
loops or recursions occur. The second stage is macro processing
(see section <A HREF="chpp.html#SEC23">The Meta-Char</A>) and allows for loops as well as for recursion.

</P>



<H2><A NAME="SEC20" HREF="chpp.html#TOC20">Commands</A></H2>

<P>
Command processing is line-oriented. It affects only lines which have,
as their first non-whitespace character, the command-char
(<CODE>#</CODE>). All other lines are passed through literally. Another
function of command processing is the concatenation of lines: If the
last character of a line is the backslash (<CODE>\</CODE>), then the
backslash, the following newline and all leading whitespace of the next
line are ignored.

</P>
<P>
A line invoking a command consists of optional whitespace at the
beginning, the command-char <CODE>#</CODE>, optional whitespace, the command
name, whitespace and the command arguments (if any). Thus, the following
lines are all commands (given that the command names exist):

</P>

<PRE>
#abc
    #def arg
 #  ghi too many arguments
</PRE>

<P>
while the following lines are not:

</P>

<PRE>
this is a line without commands.
although this line contains a # it is not a command.
</PRE>



<H3><A NAME="SEC21" HREF="chpp.html#TOC21">Comments</A></H3>

<P>
The command <CODE>!</CODE> (exclamation mark) is a special case among
commands, as it does nothing, independent of its parameters, i.e. can be
used to write comments, or, if used in the first line of a file, to
specify the command line to be used if the containing file is
executed. Thus, this is a "Hello world" program in <CODE>chpp</CODE>:

</P>

<PRE>
#! /usr/local/bin/chpp
Hello world!
</PRE>

<P>
After setting the executable bit for this file, it can be called like
any command and will produce the output

</P>

<PRE>
Hello world!
</PRE>

<P>
Note that the exclamation mark must be followed by whitespace.

</P>


<H3><A NAME="SEC22" HREF="chpp.html#TOC22">Command Reference</A></H3>

<P>
<DL>
<DT><U>Command:</U> <B>include</B> <I><VAR>filename</VAR></I>
<DD><A NAME="IDX1"></A>
Includes the file <VAR>filename</VAR>. If <VAR>filename</VAR> is relative, it is
first searched for in the directory of the including file, then in the
directories contained in the include search path (see section <A HREF="chpp.html#SEC18">Invoking <CODE>chpp</CODE></A>).
If the file is not found, an error message is produced.
</DL>

</P>
<P>
<DL>
<DT><U>Command:</U> <B>define</B> <I><VAR>name</VAR> <VAR>value</VAR></I>
<DD><A NAME="IDX2"></A>
Defines the global variable <VAR>name</VAR> to contain whatever <VAR>value</VAR>
evaluates to.
</DL>

</P>
<P>
<DL>
<DT><U>Command:</U> <B>if</B> <I><VAR>condition</VAR></I>
<DD><A NAME="IDX3"></A>
Evaluates <VAR>condition</VAR>. If its boolean value is FALSE, it skips
everything up to the corresponding <CODE>endif</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Command:</U> <B>ifdefined</B> <I><VAR>symbol</VAR></I>
<DD><A NAME="IDX4"></A>
<DT><U>Command:</U> <B>ifdef</B> <I><VAR>symbol</VAR></I>
<DD><A NAME="IDX5"></A>
If a variable with the name <VAR>symbol</VAR> does not exist, skips
everything up to the corresponding <CODE>endif</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Command:</U> <B>ifnotdefined</B> <I><VAR>symbol</VAR></I>
<DD><A NAME="IDX6"></A>
<DT><U>Command:</U> <B>ifndef</B> <I><VAR>symbol</VAR></I>
<DD><A NAME="IDX7"></A>
If a variable with the name <VAR>symbol</VAR> exists, skips everything
up to the corresponding <CODE>endif</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Command:</U> <B>error</B> <I><VAR>message</VAR></I>
<DD><A NAME="IDX8"></A>
Produces an error message with the text <VAR>message</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Command:</U> <B>discard</B>
<DD><A NAME="IDX9"></A>
<DT><U>Command:</U> <B>disc</B>
<DD><A NAME="IDX10"></A>
Discards everything up to the corresponding <CODE>endd</CODE>.
</DL>

</P>


<H2><A NAME="SEC23" HREF="chpp.html#TOC23">The Meta-Char</A></H2>

<P>
The second stage processes everything that is passed through by the
first stage. It is called macro processing because its main use is the
expansion of macros. There is just one special character for this stage,
namely the meta-char (<CODE>%</CODE>). Only character sequences beginning with
the meta-char are modified by the macro processing stage. All other
characters are simply passed through. Since <CODE>chpp</CODE> was designed to
be non-intrusive, even uses of the meta-char which do not correspond to
the uses described in this chapter are copied verbatim. For example:

</P>

<PRE>
Temperature today is 10% above average.
=> Temperature today is 10% above average.
</PRE>

<P>
In cases where it is absolutely necessary that the meta-char not be
interpreted as special, it can be quoted with itself (i.e. <CODE>%%</CODE>),
yielding one meta-char. Example:

</P>

<PRE>
%&#60;heinz=deinz&#62;\
%%heinz evals to %heinz.
=> %heinz evals to deinz.
</PRE>



<H2><A NAME="SEC24" HREF="chpp.html#TOC24">Data Types</A></H2>

<P>
The only primitive type in <CODE>chpp</CODE> is the string. Values of that
type are referred to as scalars (see section <A HREF="chpp.html#SEC25">Scalars</A>). Values of any type
can be combined arbitrarily to lists (see section <A HREF="chpp.html#SEC26">Lists</A>) and hashes
(see section <A HREF="chpp.html#SEC27">Hashes</A>). Closures (see section <A HREF="chpp.html#SEC28">Closures</A>) also form a data type as
they can be stored and used, even though they cannot be directly
manipulated.

</P>



<H3><A NAME="SEC25" HREF="chpp.html#TOC25">Scalars</A></H3>

<P>
Scalars are strings of arbitrary length (including the length 0).

</P>


<H3><A NAME="SEC26" HREF="chpp.html#TOC26">Lists</A></H3>

<P>
Lists are ordered collections of arbitrary values indexed by consecutive
numbers starting at 0. It follows that lists cannot have gaps.

</P>


<H3><A NAME="SEC27" HREF="chpp.html#TOC27">Hashes</A></H3>

<P>
Hashes are ordered collections of arbitrary values indexed by arbitrary
scalars, i.e. they establish a so-called key/value mapping.

</P>


<H3><A NAME="SEC28" HREF="chpp.html#TOC28">Closures</A></H3>

<P>
A closure is a piece of code associated with an environment in which it
is to be executed, as created by <CODE>lambda</CODE> (or <CODE>define</CODE>, for
that matter). Thus, the names macro and closure actually stand for the
same thing, although one usually tends to call anonymous macros
(i.e. values returned by <CODE>lambda</CODE>) closures, whereas named closure
(i.e. <CODE>define</CODE>d macros) are usually called macros.

</P>


<H2><A NAME="SEC29" HREF="chpp.html#TOC29">Variables</A></H2>

<P>
In order to be able to retain values for subsequent use it is necessary
to store them in variables.

</P>



<H3><A NAME="SEC30" HREF="chpp.html#TOC30">Accessing Variables</A></H3>

<P>
There are two different syntactic forms of variable access, called the
short and the long form.

</P>
<P>
The short form consists of the meta-char followed by an optional
ampersand (<CODE>&#38;</CODE>) followed by the variable name, e.g. <CODE>%name</CODE> or
<CODE>%&#38;name</CODE>. The variable name is taken as-is, i.e. is not
evaluated. The variable name ends with the first char that is not a
letter, a digit or the underscore (<CODE>_</CODE>). If a variable with the
given name does not exist, the whole string is not interpreted as a
variable access and is copied verbatim, i.e. <CODE>%name</CODE> evaluates to
<CODE>%name</CODE> if there is no variable with the name <CODE>name</CODE>.

</P>
<P>
The long form consists of the meta-char followed by the optional
ampersand and the variable name within angle brackets,
e.g. <CODE>%&#60;name&#62;</CODE> or <CODE>%&#60;&#38;name&#62;</CODE>. The variable name is evaluated
before the variable is looked up, making it possible, for example, to
use variable names containing right angle brackets: The term
<CODE>%&#60;%'&#62;&#62;&#62;'&#62;</CODE> accesses the variable <CODE>&#62;&#62;&#62;</CODE>. If a variable with
the name does not exists, an error message is issued. <STRONG>Note:</STRONG>
Although it is possible to use macros to construct variable names
(e.g. <CODE>%&#60;%name&#62;</CODE>), this feature is deprecated. Please don't use it.

</P>


<H3><A NAME="SEC31" HREF="chpp.html#TOC31">List and Hash Subscription</A></H3>

<P>
If the variable is a list or a hash, it can be subscribed by appending
the index in brackets or curly braces to the name, in both the short and
the long form. In order to access nested data structures, any number of
such indexes can be used in one access, for example
<CODE>%name[3]{foo}</CODE>.

</P>


<H3><A NAME="SEC32" HREF="chpp.html#TOC32">Copies and References</A></H3>

<P>
Accessing a variable or a subscript without an ampersand produces a
shallow copy of its value, i.e. accessing a list produces a copy of the
list containing the elements of the original list. Example:

</P>

<PRE>
%&#60;lst1=%list(a,b,c)&#62;%&#60;lst2=%lst1&#62;\
%same(%&#38;lst1,%&#38;lst2) : %same(%&#38;lst1[0],%&#38;lst2[0])
=> 0 : 1
</PRE>

<P>
Accessing a variable or subscript with an ampersand produces the same
value, i.e. can be used to bind two names to the same value:

</P>

<PRE>
%&#60;str1=abc&#62;%&#60;str2=%&#38;str1&#62;\
%same(%&#38;str1,%&#38;str2)
=> 1
</PRE>

<P>
There are several important issues to this:

</P>

<UL>
<LI>

Copying values is of course slower than just reusing the same
value. <CODE>chpp</CODE>'s built-in macros, however, are wise enough not to
copy their arguments when they don't need to. For example, calling
<CODE>llength</CODE> never copies its argument.

<LI>

Circular data structures can be built easily. Care has to be taken when
processing these structures, or one might end up in an endless loop.

<LI>

Memory management becomes more complicated when arbitrary
cross-references in data-structures are allowed. This, however, need not
concern the <CODE>chpp</CODE> user, as it employs garbage collection to free
unused memory.
</UL>



<H3><A NAME="SEC33" HREF="chpp.html#TOC33">Macro Invocation</A></H3>

<P>
A macro can be invoked by appending, in the short or long form of
variable access, to the variable name or subscript a left parenthesis
followed by the actual arguments separated by commas followed by a right
parenthesis, e.g. <CODE>%list(a,b)</CODE>. The value that is yielded by the
macro invocation cannot be subscribed further, i.e. <CODE>%list(a,b)[1]</CODE>
is not allowed. However, see section <A HREF="chpp.html#SEC34">Subscribing Non-Variables</A> for a
method to achieve this goal.

</P>
<P>
Arguments of a macro-call are processed as follows: First, all leading
and trailing whitespace from all arguments is removed. Then, the
remaining strings are evaluated and the results are passed as arguments
to the macro. In order to pass an argument with leading or trailing
whitespace to a macro, it must be quoted. For example:

</P>

<PRE>
%define(foobar,arg,"%arg")

%foobar(  xyz  )
=> "xyz"
%foobar(    )
=> ""
%foobar(  %'  '  )
=> "  "
%foobar(%'  xyz  ')
=> "  xyz  "
</PRE>



<H3><A NAME="SEC34" HREF="chpp.html#TOC34">Subscribing Non-Variables</A></H3>

<P>
It is possible to subscribe values that are not variables, for example
ones that are returned from macros, by using a modified long form of
variable access. Instead of the variable name the expression yielding
the value enclosed in parentheses is used. Upon evaluation, the
expression is evaluated and all following subscriptions are applied to
its value. Example:

</P>

<PRE>
%&#60;(%list(a,b))[1]&#62;
=> b
</PRE>



<H3><A NAME="SEC35" HREF="chpp.html#TOC35">Assignment</A></H3>

<P>
Assignment syntax is an enhancement of the long form of variable access.
The last subscription (or the variable name, if no subscription is used)
is followed by an equal sign (<CODE>=</CODE>) which is followed by an
expression yielding the value to be assigned.

</P>
<P>
When assignment is attempted to an element of a list which is out of
bounds, the list is enlarged. Elements between the formerly last element
and the newly added element default to the empty string. Indexes less
then 0 are not allowed.

</P>
<P>
Assigning to a key in a hash which is not part of it, adds the key/value
pair to the hash.

</P>
<P>
It is not possible to assign to a subscript of a value which is not
subscribeable, i.e. it is not possible to do <CODE>%&#60;bar[3]=foo&#62;</CODE> if
<CODE>bar</CODE> is not a list. To make <CODE>bar</CODE> an empty list, simply do
<CODE>%&#60;bar=%list()&#62;</CODE>.

</P>
<P>
Assignment usually changes a binding, be it in an environment or in a
list or hash. This means that the sequence

</P>

<PRE>
%&#60;value=%list()&#62;%&#60;value=%hash()&#62;
</PRE>

<P>
first binds the name <CODE>value</CODE> to a newly created list and then
rebinds <CODE>value</CODE> to a newly created hash, leaving the old list
intact. When using the ampersand-form, however, the old value is changed
to the new value, which is a destructive process. Example:

</P>

<PRE>
%&#60;value=abc&#62;%&#60;ref=%&#38;value&#62;%&#60;&#38;value=123&#62;%ref
=> 123
</PRE>

<P>
When an assignment to a variable is executed for which there is no
binding, a new binding in the global environment is created for this
variable name.

</P>


<H3><A NAME="SEC36" HREF="chpp.html#TOC36">Scoping Rules</A></H3>

<P>
<CODE>chpp</CODE> uses lexical scoping, using an environmental model, very
similar to Scheme's. An environment contains bindings for names to
values and a reference to its parent environment. The only environment
without parent is the global environment. Execution always takes place
in some environment. If a variable name has to be resolved, the current
environment is checked for whether it contains a binding for that
name. If it does not, its parent is checked, and so on until the global
environment is reached. If it does not contain a corresponding binding,
the variable name cannot be resolved and an error message is produced.

</P>
<P>
New environments are created upon several occasions:

</P>

<UL>
<LI>

The execution of a <CODE>locals</CODE> expression. The new environment is set
up to contain bindings for all the variables mentioned as parameters to
<CODE>locals</CODE>. The parent environment of the new environment is the
environment active at the time of execution of the expression. The
environment is active throughout the body of the <CODE>locals</CODE>
expression.

<LI>

The execution of a closure (i.e. the value returned by an invocation of
<CODE>lambda</CODE> or the value bound to a name as a result of an invocation
of <CODE>define</CODE>). The environment is set up to contain bindings for all
the parameters of the closure. The parent environment of this new
environment is the environment active at the time of the generation of
the closure, i.e. of the invocation of <CODE>lambda</CODE>. That makes it
possible to do things like this:


<PRE>
%define(newcounter,%locals(c,%&#60;c=0&#62;%lambda(%&#60;c=%[c+1]&#62;%c)))\
%&#60;counter=%newcounter()&#62;\
%counter() %counter() %counter()
=> 1 2 3
</PRE>

The parent environment for the environments of the closure invocations
is the environment created by <CODE>locals</CODE>, mapping <CODE>c</CODE> to
<CODE>0</CODE>, which is itself created every time <CODE>newcounter</CODE> is
executed. Thus, in a way, <CODE>counter</CODE> carries a state, namely its
private variable <CODE>c</CODE>. Had we called <CODE>newcounter</CODE> a second
time, a second counter would have been created, with its own <CODE>c</CODE>,
initally set to <CODE>0</CODE>, completely independent of the first.

<LI>

The execution of <CODE>for</CODE>, <CODE>foreach</CODE> and <CODE>foreachkey</CODE>
expressions (see section <A HREF="chpp.html#SEC41">Special Forms</A>).
</UL>



<H2><A NAME="SEC37" HREF="chpp.html#TOC37">Arithmetic Expansion</A></H2>

<P>
<CODE>chpp</CODE> permits the evaluation of arithmetic expressions by
enclosing the expression in square brackets (<CODE>[]</CODE>) preceded by the
meta-char. The expression is first evaluated according to <CODE>chpp</CODE>
rules and the resulting value is treated as an arithmetic expression
which, in turn, yields a number. Whitespace between operators and
operands is ignored. The following table is a summary of all available
operators together with their arity. They are sorted by precedence, the
first line being of the highest precedence. All binary operators
evaluate from left to right. All operators have the same meaning as the
corresponding operators in the C language.

</P>
<P>
@multitable @columnfractions .2 .8
<LI><STRONG>Operators</STRONG>                       @tab <STRONG>Arity</STRONG>

<LI><CODE>!</CODE>, <CODE>~</CODE>, <CODE>-</CODE>             @tab unary

<LI><CODE>*</CODE>, <CODE>/</CODE>, <CODE>%</CODE>             @tab binary

<LI><CODE>+</CODE>, <CODE>-</CODE>                       @tab binary

<LI><CODE>&#60;</CODE>, <CODE>&#62;</CODE>, <CODE>&#60;=</CODE>, <CODE>&#62;=</CODE> @tab binary

<LI><CODE>==</CODE>, <CODE>!=</CODE>                     @tab binary

<LI><CODE>&#38;</CODE>                                 @tab binary

<LI><CODE>^</CODE>                                 @tab binary

<LI><CODE>|</CODE>                                 @tab binary

<LI><CODE>&#38;&#38;</CODE>                                @tab binary

<LI><CODE>||</CODE>                                @tab binary

Precedence of operators can be overridden by using parentheses
(<CODE>()</CODE>).

In order to make arithmetic expressions more readable, it is allowed to
refer to the values of variables within an arithmetic expression by
writing its name--without a preceding meta-char. Note that subscription
and macro invocation using this syntax is not allowed.

Some examples:


<PRE>
%[1+2]
=> 3
%[1.5+3.3]
=> 4.800000
%[3==3]
=> 1
%[3!=3]
=> 0
%[(1+2)*(3+4)]
=> 21
%&#60;x=4&#62;%[%x+1]
=> 5
%&#60;x=4&#62;%[x+1]
=> 5
</PRE>



<H2><A NAME="SEC38" HREF="chpp.html#TOC38">Quotation</A></H2>

<P>
To prevent some string from evaluation, it can be quoted by enclosing it
in a pair of single-quotes (<CODE>"</CODE>), preceded by the meta-char. The
only special characters after the first double-quote are the quote-char
(the backslash, <CODE>\</CODE>) and the closing double-quote. The quote-char
gives special meanings to some characters following it: an <CODE>n</CODE>
becomes a newline character and a <CODE>t</CODE> is interpreted as a
tabulator. All other character preceded by the quote-char stand for
themselves. This includes the quote-char and the double-quote,
i.e. <CODE>%'\\\"</CODE> evaluates to <CODE>\'</CODE>.

</P>


<H2><A NAME="SEC39" HREF="chpp.html#TOC39">Explicit Evaluation</A></H2>

<P>
In order to evaluate a string twice, for example to evaluate the
contents of a variable, the string must be enclosed in curly braces
(<CODE>{}</CODE>), preceded by the meta-char. Example:

</P>

<PRE>
%&#60;a=abc&#62;%&#60;b=%%a&#62;%{%b}
=> abc
</PRE>



<H1><A NAME="SEC40" HREF="chpp.html#TOC40">Extending <CODE>chpp</CODE></A></H1>



<H1><A NAME="SEC41" HREF="chpp.html#TOC41">Special Forms</A></H1>

<P>
Special forms, although syntactically equivalent to macros, differ from
macros in that their arguments are not automatically evaluated before
they are called. The evaluation of their arguments usually depend on
some condition of some other argument.

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>if</B> <I>(<VAR>condition</VAR>,<VAR>consequent</VAR>[,<VAR>alternative</VAR>])</I>
<DD><A NAME="IDX11"></A>
Evaluates <VAR>condition</VAR> and, if its boolean value is TRUE, evaluates
<VAR>consequent</VAR>. Otherwise, <VAR>alternative</VAR> is evaluated, if
specified.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>cond</B> <I>([<VAR>condition</VAR>,<VAR>consequent</VAR>[,...]])</I>
<DD><A NAME="IDX12"></A>
Evaluates the <VAR>condition</VAR>s one at a time and checks for their
boolean value. If a <VAR>condition</VAR> with a value of TRUE is encountered,
its corresponding <VAR>consequent</VAR> is evaluated and its result
returned. If no <VAR>condition</VAR> evaluates to TRUE, nothing is
done. Example:

</P>

<PRE>
%&#60;number=23&#62;\
%cond(%[number &#60; 10],less than 10,
      %[number &#60; 50],less than 50 but greater than 9,
      else,greater than 49)
=> less than 50 but greater than 9
</PRE>

</DL>

<P>
<DL>
<DT><U>Special Form:</U> <B>case</B> <I>(<VAR>string</VAR>,<VAR>list</VAR>,<VAR>consequent</VAR>[,...[,<CODE>else</CODE>,<VAR>alternative</VAR>]])</I>
<DD><A NAME="IDX13"></A>
Evaluates <VAR>string</VAR> to a scalar. Then, one at a time evaluates each
<VAR>list</VAR> and checks whether <VAR>string</VAR> is contained in the resulting
list. If it is, the corresponding <VAR>consequent</VAR> is evaluated and its
result returned. If the <CODE>else</CODE> clause is specified and the string
is contained in no list, its <VAR>alternative</VAR> is evaluated. Otherwise,
nothing is done. Example:

</P>

<PRE>
%&#60;number=7&#62;\
%case(%number,
      %list(0,2,4,6,8),even,
      %list(1,3,5,7,9),odd)
=> odd
</PRE>

</DL>

<P>
<DL>
<DT><U>Special Form:</U> <B>for</B> <I>(<VAR>counter</VAR>,<VAR>start</VAR>,<VAR>stop</VAR>,[<VAR>increment</VAR>,]<VAR>body</VAR>)</I>
<DD><A NAME="IDX14"></A>
Evaluates <VAR>counter</VAR>, <VAR>start</VAR>, <VAR>stop</VAR> and, if specified,
<VAR>increment</VAR>. The values of <VAR>start</VAR>, <VAR>stop</VAR> and
<VAR>increment</VAR> must be integer numbers. If <VAR>increment</VAR> is not
specified, an increment of @math{1} is used if <VAR>start</VAR> is greater
than <VAR>stop</VAR>, otherwise @math{-1}. Then counts, beginning with
<VAR>start</VAR>, while the value of the counter is before or equal to
<VAR>stop</VAR> in the counting direction. For each step, evaluates
<VAR>body</VAR> in a new environment where <VAR>counter</VAR> is bound to the
value of the counter.

</P>
<P>
A few examples:

</P>

<PRE>
%for(i,1,10,%i%' ')
=> 1 2 3 4 5 6 7 8 9 10
%for(i,10,1,%i%' ')
=> 10 9 8 7 6 5 4 3 2 1
%for(i,1,10,2,%i%' ')
=> 1 3 5 7 9
%for(i,10,1,-2,%i%' ')
=> 10 8 6 4 2
%for(i,1,10,0,%i%' ')
error--> increment in for-loop cannot be zero
%for(i,10,1,1,%i%' ')
=>
</PRE>

</DL>

<P>
<DL>
<DT><U>Special Form:</U> <B>foreach</B> <I>(<VAR>counter</VAR>,<VAR>list</VAR>,<VAR>body</VAR>)</I>
<DD><A NAME="IDX15"></A>
Evaluates <VAR>counter</VAR> and <VAR>list</VAR>, which must yield a list. Then
iterates over this list evaluating <VAR>body</VAR> in a new environment in which
<VAR>counter</VAR> is bound to the current list element.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>foreachkey</B> <I>(<VAR>counter</VAR>,<VAR>hash</VAR>,<VAR>body</VAR>)</I>
<DD><A NAME="IDX16"></A>
Evaluates <VAR>counter</VAR> and <VAR>hash</VAR>, which must yield a hash. Then
iterates over all keys in the hash evaluating <VAR>body</VAR> in a new environment
in which <VAR>counter</VAR> is bound to the current hash key.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>while</B> <I>(<VAR>condition</VAR>,<VAR>expr</VAR>)</I>
<DD><A NAME="IDX17"></A>
Evaluates <VAR>condition</VAR>. If this yields a boolean value of TRUE,
<VAR>expr</VAR> is evaluated, otherwise the loop is finished. Then repeats the
cycle.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>until</B> <I>(<VAR>condition</VAR>,<VAR>expr</VAR>)</I>
<DD><A NAME="IDX18"></A>
Evaluates <VAR>condition</VAR>. If this yields a boolean value of TRUE, the
loop is finished, otherwise <VAR>expr</VAR> is evaluated. Then repeats the
cycle.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>dowhile</B> <I>(<VAR>expr</VAR>,<VAR>condition</VAR>)</I>
<DD><A NAME="IDX19"></A>
Evaluates <VAR>expr</VAR>, then evaluates <VAR>condition</VAR>. If this yields
a boolean value of TRUE, the cycle is repeated.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>dountil</B> <I>(<VAR>expr</VAR>,<VAR>condition</VAR>)</I>
<DD><A NAME="IDX20"></A>
Evaluates <VAR>expr</VAR>, then evaluates <VAR>condition</VAR>. If this yields a
boolean value of TRUE, the loop is finished, otherwise the cycle is
repeated.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>and</B> <I>([<VAR>expr</VAR>[,...]])</I>
<DD><A NAME="IDX21"></A>
Evaluates the <VAR>expr</VAR>s from left to right. For the first <VAR>expr</VAR>
evaluating to boolean FALSE, returns <CODE>0</CODE>. If all <VAR>expr</VAR>s
evaluate to boolean TRUE, returns <CODE>1</CODE>. This means that if one
<VAR>expr</VAR> evaluates to FALSE, all <VAR>expr</VAR>s to its right do not get
evaluated. If <CODE>and</CODE> is called without parameters, it returns
<CODE>1</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>or</B> <I>([<VAR>expr</VAR>[,...]])</I>
<DD><A NAME="IDX22"></A>
Evaluates the <VAR>expr</VAR>s from left to right. For the first <VAR>expr</VAR>
evaluating to boolean TRUE, returns <CODE>1</CODE>. If all <VAR>expr</VAR>s
evaluate to boolean FALSE, returns <CODE>0</CODE>. This means that if one
<VAR>expr</VAR> evaluates to TRUE, all <VAR>expr</VAR>s to its right do not get
evaluated. If <CODE>or</CODE> is called without parameters, it returns
<CODE>0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>define</B> <I>(<VAR>name</VAR>,<VAR>argname</VAR>[,<VAR>argname</VAR>...],<VAR>body</VAR>)</I>
<DD><A NAME="IDX23"></A>
Defines a macro with the name <VAR>name</VAR> and the specified argument
names. The body <VAR>body</VAR> is not evaluated.
</DL>

</P>
<P>
<DL>
<DT><U>Special Form:</U> <B>locals</B> <I>(<VAR>symbol</VAR>[,<VAR>symbol</VAR>...],<VAR>body</VAR>)</I>
<DD><A NAME="IDX24"></A>
Evaluates <VAR>body</VAR> in a new scope with the specified local variables.
</DL>

</P>



<H1><A NAME="SEC42" HREF="chpp.html#TOC42">Macros</A></H1>



<H2><A NAME="SEC43" HREF="chpp.html#TOC43">List Operations</A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>list</B> <I>([<VAR>element</VAR>,...])</I>
<DD><A NAME="IDX25"></A>
Returns a list containing all specified <VAR>element</VAR>s in the specified
order, beginning with index 0. Note that <CODE>%list()</CODE> returns an empty
list while <CODE>%list(%")</CODE> returns a list with one element, which is
the empty string.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>llength</B> <I>(<VAR>list</VAR>)</I>
<DD><A NAME="IDX26"></A>
Returns the number of elements in the list <VAR>list</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>linsert</B> <I>(<VAR>list</VAR>,<VAR>index</VAR>,<VAR>element</VAR>)</I>
<DD><A NAME="IDX27"></A>
Inserts the element <VAR>element</VAR> into the list <VAR>list</VAR> at index
<VAR>index</VAR>. If <VAR>index</VAR> is greater or equal the length of
<VAR>list</VAR>, the list is enlarged by appending empty strings. Examples:

</P>

<PRE>
%&#60;lst=%list(a,b,c)&#62;

%linsert(%&#38;lst,1,x)%encode(%lst)
=> %list(%'a',%'x',%'b',%'c')
%linsert(%&#38;lst,5,y)%encode(%lst)
=> %list(%'a',%'x',%'b',%'c',%",%'y')
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>ldelete</B> <I>(<VAR>list</VAR>,<VAR>index</VAR>)</I>
<DD><A NAME="IDX28"></A>
Deletes from the list <VAR>list</VAR> the element at index
<VAR>index</VAR>. Example:

</P>

<PRE>
%&#60;lst=%list(a,b,c)&#62;%ldelete(%&#38;lst,1)%encode(%lst)
=> %list(%'a',%'c')
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>lsort</B> <I>(<VAR>list</VAR>[,<VAR>comparator</VAR>])</I>
<DD><A NAME="IDX29"></A>
Sorts the elements of the list <VAR>list</VAR>, which should be strings,
according to the order specified by <VAR>comparator</VAR>, which must be a
closure taking two arguments and returning an integer. A return value of
<CODE>0</CODE> denotes that the two arguments are equal, less than <CODE>0</CODE>
means that the first argument should come before the second, greater
than <CODE>0</CODE> means that the first argument should come after the
second. If <VAR>comparator</VAR> is omitted, the macro <CODE>scmp</CODE> is used.
Returns the resulting list. Examples:

</P>

<PRE>
%encode(%lsort(%list(b,c,a)))
=> %list(%'a',%'b',%'c')
%encode(%lsort(%list(b,c,a),%lambda(a,b,%scmp(%b,%a))))
=> %list(%'c',%'b',%'a')
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>lappend</B> <I>(<VAR>list</VAR>,<VAR>value</VAR>[,<VAR>value</VAR>...])</I>
<DD><A NAME="IDX30"></A>
Appends all <VAR>value</VAR>s to the list <VAR>list</VAR>. Returns nothing,
i.e. is called for its side effects, which means that the first
parameter should be a list to be modified, not a copy of a list.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>luniq</B> <I>(<VAR>list</VAR>[,<VAR>comparator</VAR>])</I>
<DD><A NAME="IDX31"></A>
Removes all but the first occurrences of all sequential occurrences of the
same element in <VAR>list</VAR>, where the sameness is determined by the
closure <VAR>comparator</VAR>, which must accept two arguments and return a
boolean value of TRUE if they are equal, FALSE otherwise. If
<VAR>comparator</VAR> is omitted, <CODE>seq</CODE> is used. Returns the modified
<VAR>list</VAR>.

</P>

<PRE>
%encode(%luniq(%list(a,b,b,c,d,e,e,e,f)))
=> %list(%'a',%'b',%'c',%'d',%'e',%'f')
</PRE>

</DL>



<H2><A NAME="SEC44" HREF="chpp.html#TOC44">Hash Operations</A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>hash</B> <I>([<VAR>key</VAR>,<VAR>value</VAR>,...])</I>
<DD><A NAME="IDX32"></A>
Returns a hash containing all the specified key/value pairs.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>hcount</B> <I>(<VAR>hash</VAR>)</I>
<DD><A NAME="IDX33"></A>
Returns the number of key/value pairs in the hash <VAR>hash</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>hcontains</B> <I>(<VAR>hash</VAR>,<VAR>key</VAR>)</I>
<DD><A NAME="IDX34"></A>
Returns <CODE>1</CODE>, if the key <VAR>key</VAR> is contained in the hash
<VAR>hash</VAR>. Otherwise, returns <CODE>0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>hkeys</B> <I>(<VAR>hash</VAR>)</I>
<DD><A NAME="IDX35"></A>
Returns a list of all keys in the hash <VAR>hash</VAR> in no particular
order.
</DL>

</P>


<H2><A NAME="SEC45" HREF="chpp.html#TOC45">File Operations</A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>fopen</B> <I>(<VAR>filename</VAR>[,<VAR>mode</VAR>])</I>
<DD><A NAME="IDX36"></A>
Opens the file named <VAR>filename</VAR> and returns a handle to it. If the
file could not be opened, for example because it does not exists, for
lack of permission or if <VAR>mode</VAR> is illegal, returns <CODE>-1</CODE>.  The
file is opened for reading if <VAR>mode</VAR> is omitted or is <CODE>r</CODE>. The
file is opened for writing if <VAR>mode</VAR> is <CODE>w</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>fpipe</B> <I>(<VAR>executable</VAR>[,<VAR>arg</VAR>...])</I>
<DD><A NAME="IDX37"></A>
Forks off a child process, starts the specified executable with the
specified parameters and returns a handle for reading this processes
standard output. Returns <CODE>-1</CODE> if something goes wrong. Note that
the arguments are not subject to shell expansion, since the process does
not start a subshell. If you want shell expansion, you have to start a
subshell explicitly. For example, to list all files beginning with an
<CODE>a</CODE>:

</P>

<PRE>
%pipe(/bin/sh,-c,ls a*)
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>fclose</B> <I>(<VAR>file</VAR>)</I>
<DD><A NAME="IDX38"></A>
Closes the file associated with the handle <VAR>file</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>fgets</B> <I>(<VAR>file</VAR>)</I>
<DD><A NAME="IDX39"></A>
Reads one line from the file associated with the handle <VAR>file</VAR> and
returns it. The newline character is included.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>fputs</B> <I>(<VAR>file</VAR>,<VAR>string</VAR>)</I>
<DD><A NAME="IDX40"></A>
Writes <VAR>string</VAR> to the file associated with the handle <VAR>file</VAR>,
which must have been opened for writing.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>feof</B> <I>(<VAR>file</VAR>)</I>
<DD><A NAME="IDX41"></A>
Returns boolean TRUE if the end of the file associated with the handle
<VAR>file</VAR> is reached, FALSE otherwise.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>fstat</B> <I>(<VAR>filename</VAR>)</I>
<DD><A NAME="IDX42"></A>
Returns a hash containing information on the file with name
<VAR>filename</VAR>. Returns an empty hash if the file does not
exist. Otherwise, the hash contains values for the following keys:

</P>
<DL COMPACT>

<DT><CODE>uid</CODE>
<DD>
User ID of owner.
<DT><CODE>gid</CODE>
<DD>
Group ID of owner.
<DT><CODE>size</CODE>
<DD>
Size in bytes.
<DT><CODE>blksize</CODE>
<DD>
Blocksize for filesystem I/O.
<DT><CODE>blocks</CODE>
<DD>
Number of blocks allocated.
<DT><CODE>atime</CODE>
<DD>
Time of last access.
<DT><CODE>mtime</CODE>
<DD>
Time of last modification.
<DT><CODE>ctime</CODE>
<DD>
Time of last change.
</DL>

<P>
All times are given in seconds since January 1, 1970, 00:00:00 GMT. For
detailed description of these values see <CODE>stat(2)</CODE>.
</DL>

</P>


<H2><A NAME="SEC46" HREF="chpp.html#TOC46">String Operations</A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>smatch</B> <I>(<VAR>regexp</VAR>,<VAR>string</VAR>[,<VAR>registers</VAR>])</I>
<DD><A NAME="IDX43"></A>
Searches the string <VAR>string</VAR> for the first occurrence of the regular
expression <VAR>regexp</VAR> and returns the index of the first character of
this substring. If no match was found, returns <CODE>-1</CODE>. If
<VAR>registers</VAR> is specified, which must be a list, clears it and sets
its elements (beginning with @math{1}) to the contents of the
corresponding submatches (parts of the regular expression enclosed by
parentheses). The element <CODE>0</CODE> is set to the whole match. For
example:

</P>

<PRE>
%&#60;regs=%list()&#62;\
%smatch(%'\.([^.]*)$',alittlepicture.jpg,%&#38;regs) %regs[1]
=> 14 jpg
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>ssplit</B> <I>(<VAR>regexp</VAR>,<VAR>string</VAR>[,<VAR>connector</VAR>])</I>
<DD><A NAME="IDX44"></A>
Splits the string <VAR>string</VAR> into parts separated by the regular
expression <VAR>regexp</VAR>. Returns a list containing these parts. If
<VAR>connector</VAR> is specified, the parts that are inserted into the list
are generated by invocations of <VAR>connector</VAR>. <VAR>connector</VAR> is
always called with three parameters, the first being the registers of
<VAR>regexp</VAR> for the match right before the string and the third being
the registers of the match right after the string. The second parameter
is the string itself. For the very first string, the first parameter is
an empty list, whereas for the last string, the third parameter is an
empty list. Thus

</P>

<PRE>
%ssplit(%regex,%string)
</PRE>

<P>
is equivalent to

</P>

<PRE>
%ssplit(%regex,%string,%lambda(a,b,c,%b))
</PRE>

<P>
Example:

</P>

<PRE>
%encode(%ssplit(:+,foo::bar:rules))
=> %list(%'foo',%'bar',%'rules')
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>stokenize</B> <I>(<VAR>regexp</VAR>,<VAR>string</VAR>[,<VAR>tokener</VAR>])</I>
<DD><A NAME="IDX45"></A>
Returns a list containing all substrings of <VAR>string</VAR> matching
<VAR>regexp</VAR>. If <VAR>tokener</VAR> is specified, not the whole matches are
inserted into the result list, but the results of calling <VAR>tokener</VAR>
with the respective lists of registers of the matches. This means, that
these two calls have the same result:

</P>

<PRE>
%stokenize(%regexp,%string)
%stokenize(%regexp,%string,%lambda(r,%r[0]))
</PRE>

<P>
Examples:

</P>

<PRE>
%encode(%stokenize([a-zA-Z0-9]+,%' a bc d04 d   fsfd, rwe'))
=> %list(%'a',%'bc',%'d04',%'d',%'fsfd',%'rwe')
%encode(%stokenize(%'-([0-9]+)-',%'  -32- -- 543 -12--43--',
                   %lambda(r,%r[1])))
=> %list(%'32',%'12',%'43')
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>sgsub</B> <I>(<VAR>regexp</VAR>,<VAR>string</VAR>,<VAR>replacement</VAR>[,<VAR>options</VAR>])</I>
<DD><A NAME="IDX46"></A>
Replaces all occurrences of the regular expression <VAR>regexp</VAR> in
<VAR>string</VAR>. If <VAR>replacement</VAR> is a string, the occurrences are
replaced with this string. Otherwise, <VAR>replacement</VAR> must be a
closure taking one argument and returning a string. In this case, the
occurrences are replaced by the result of the closure when called with a
list containing the regular expression registers in elements beginning
with <CODE>1</CODE> and the whole match in element <CODE>0</CODE>. <VAR>options</VAR>, if
specified, should be a string composed of one or more of the following
characters:

</P>
<DL COMPACT>

<DT><CODE>i</CODE>
<DD>
Match case insensitively. The default is case-sensitive matching.
</DL>

<P>
Examples:

</P>

<PRE>
%sgsub(ei,HEINZI Deinzi,!,i)
=> H!NZI D!nzi
%sgsub(a+,abaacaaadaaaa,%lambda(r,%slength(%r[0])))
=> 1b2c3d4
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>sremovews</B> <I>(<VAR>string</VAR>)</I>
<DD><A NAME="IDX47"></A>
Returns a string which results from removing all leading and trailing
whitespace from the string <VAR>string</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>slength</B> <I>(<VAR>string</VAR>)</I>
<DD><A NAME="IDX48"></A>
Returns the length of the string <VAR>string</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>ssub</B> <I>(<VAR>string</VAR>,<VAR>start</VAR>[,<VAR>length</VAR>])</I>
<DD><A NAME="IDX49"></A>
Returns a substring of the string <VAR>string</VAR>. If it is called with two
arguments and <VAR>start</VAR> is positive, then the substring beginning with
index <VAR>start</VAR> is returned. If <VAR>start</VAR> is negative, the last
<VAR>-start</VAR> characters are returned. If called with two
arguments, <VAR>start</VAR> specifies the index of the first character in the
substring. If <VAR>length</VAR> is positive, it specifies the length of
substring. If it is negative, then <VAR>-length</VAR> specifies the
index of the character following the last character of the substring.
Examples:

</P>

<PRE>
%substring(0123456789,3)
=> 3456789
%substring(0123456789,-3)
=> 789
%substring(0123456789,2,3)
=> 234
%substring(0123456789,2,-5)
=> 234
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>scmp</B> <I>(<VAR>string1</VAR>,<VAR>string2</VAR>)</I>
<DD><A NAME="IDX50"></A>
Returns the result of the <CODE>strcmp()</CODE> C function with <VAR>string1</VAR>
and <VAR>string2</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>schr</B> <I>(<VAR>code</VAR>)</I>
<DD><A NAME="IDX51"></A>
Returns a string with the character with character code <VAR>code</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>snumber</B> <I>(<VAR>number</VAR>,<VAR>base</VAR>)</I>
<DD><A NAME="IDX52"></A>
Formats the decimal integer <VAR>number</VAR> according to the given base
<VAR>base</VAR>, which must be between 2 and 36 inclusive. Example:

</P>

<PRE>
%snumber(34,2)
=> 100010
%snumber(-255,16)
=> -ff
</PRE>

</DL>



<H2><A NAME="SEC47" HREF="chpp.html#TOC47">Miscellaneous</A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>void</B> <I>(<VAR>expr</VAR>)</I>
<DD><A NAME="IDX53"></A>
Executes <VAR>expr</VAR> but discard the result. Example:

</P>

<PRE>
%&#60;regs=%list()&#62;\
%void(%smatch(%'\.([^.]*)$',alittlepicture.jpg,%&#38;regs))%regs[1]
=> jpg
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>outputenable</B> <I>(<VAR>flag</VAR>)</I>
<DD><A NAME="IDX54"></A>
If the boolean value of <VAR>flag</VAR> is TRUE, enables output, otherwise
disables it. If output is disabled, everything is evaluated as usual,
but <CODE>chpp</CODE> does not output anything.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>depend</B> <I>(<VAR>dependency</VAR>[,<VAR>target</VAR>])</I>
<DD><A NAME="IDX55"></A>
Adds the filename <VAR>dependency</VAR> to the list of dependencies for the
file <VAR>target</VAR>. If <VAR>target</VAR> is not specified, the name of the
output file is used.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>warning</B> <I>(<VAR>message</VAR>)</I>
<DD><A NAME="IDX56"></A>
Causes <CODE>chpp</CODE> to give a warning with the message <VAR>message</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>error</B> <I>(<VAR>message</VAR>)</I>
<DD><A NAME="IDX57"></A>
Causes <CODE>chpp</CODE> to signal an error with the message <VAR>message</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>encode</B> <I>(<VAR>value</VAR>)</I>
<DD><A NAME="IDX58"></A>
Returns a string which, upon evaluation, yields a value equal to <VAR>value</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>random</B> <I>(<VAR>limit</VAR>)</I>
<DD><A NAME="IDX59"></A>
Returns a random number in the interval 0 to <VAR>limit</VAR>-1. The
random number are uniformly distributed.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>same</B> <I>(<VAR>val1</VAR>,<VAR>val2</VAR>)</I>
<DD><A NAME="IDX60"></A>
Returns <CODE>1</CODE> if <VAR>val1</VAR> and <VAR>val2</VAR> refer to the same value,
otherwise <CODE>0</CODE>. Two values are the same if a change in one entails
the same change in the other, i.e. if they occupy the same memory
location. Examples:

</P>

<PRE>
%&#60;val=abc&#62;%same(%val,%val)
=> 0
%&#60;val=abc&#62;%same(%&#38;val,%&#38;val)
=> 1
%&#60;val=abc&#62;%&#60;val2=%&#38;val&#62;%same(%&#38;val,%&#38;val2)
=> 1
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>equal</B> <I>(<VAR>val1</VAR>,<VAR>val2</VAR>)</I>
<DD><A NAME="IDX61"></A>
Returns <CODE>1</CODE> if <VAR>val1</VAR> is equal to <VAR>val2</VAR>, otherwise
<CODE>0</CODE>. Two scalars are equal if the strings they contain are
equal. Two lists are equal if they have the same length and contain
equal elements. Two hashes are equal if they have the same count and the
same keys map to equal values.

</P>

<PRE>
%equal(%list(a,b,c),%list(a,b,c))
=> 1
%equal(%hash(a,1,b,2,c,3),%hash(c,3,b,2,a,1))
=> 1
%equal(%list(a,b,c),%list(1,2,3))
=> 0
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>typeof</B> <I>(<VAR>value</VAR>)</I>
<DD><A NAME="IDX62"></A>
Returns the type of <VAR>value</VAR>. The result can be one of <CODE>scalar</CODE>,
<CODE>list</CODE>, <CODE>hash</CODE>, <CODE>lambda</CODE>, <CODE>built-in</CODE>.

</P>

<PRE>
%typeof(abc)
=> scalar
%typeof(%list(a,b,c))
=> list
%typeof(%hash(a,1,b,2,c,3))
=> hash
%typeof(%lambda(a,%a%a))
=> lambda
%typeof(%typeof)
=> built-in
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>bound</B> <I>(<VAR>name</VAR>)</I>
<DD><A NAME="IDX63"></A>
Returns <CODE>1</CODE> if the name <VAR>name</VAR> is bound in the current
environment. If not, returns <CODE>0</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>apply</B> <I>(<VAR>lambda</VAR>,<VAR>arglist</VAR>)</I>
<DD><A NAME="IDX64"></A>
Calls <VAR>lambda</VAR> with the elements of <VAR>arglist</VAR> as arguments.

</P>

<PRE>
%apply(%lambda(a,b,c,my args are %a %b %c),%list(1,2,3))
=> my args are 1 2 3
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>not</B> <I>(<VAR>expr</VAR>)</I>
<DD><A NAME="IDX65"></A>
Returns the negation of the boolean value of <VAR>expr</VAR>, i.e. returns
<CODE>1</CODE> if <VAR>expr</VAR> is FALSE and <CODE>0</CODE> if <VAR>expr</VAR> is TRUE.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>shexencode</B> <I>(<VAR>string</VAR>)</I>
<DD><A NAME="IDX66"></A>
Translates the bytes of <VAR>string</VAR> to a sequence of hexadecimal
digits.

</P>

<PRE>
%shexencode(hello world!)
=> 68656C6C6F20776F726C6421
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>shexdecode</B> <I>(<VAR>string</VAR>)</I>
<DD><A NAME="IDX67"></A>
Translates a sequence of hexadecimal digits as produced by
<CODE>shexencode</CODE> to a string.

</P>

<PRE>
%shexdecode(68656C6C6F20776F726C6421)
=> hello world!
</PRE>

</DL>



<H1><A NAME="SEC48" HREF="chpp.html#TOC48">Internal Variables</A></H1>

<P>
<DL>
<DT><U>Variable:</U> <B>outputenabled</B>
<DD><A NAME="IDX68"></A>
Is <CODE>1</CODE> if output is enabled, <CODE>0</CODE> otherwise. Output can be
enabled and disabled with the macro <CODE>outputenable</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> <B>dependencing</B>
<DD><A NAME="IDX69"></A>
Is <CODE>1</CODE> if <CODE>chpp</CODE> was started to generate dependencies (option
<CODE>--generate-dependencies</CODE>), <CODE>0</CODE> otherwise.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> <B>mainfilename</B>
<DD><A NAME="IDX70"></A>
Is set to the filename of the currently executed top-level source file.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> <B>env</B>
<DD><A NAME="IDX71"></A>
Is a hash containing all environment variables of the process.

</P>

<PRE>
%env{TERM}
=> xterm
</PRE>

</DL>



<H1><A NAME="SEC49" HREF="chpp.html#TOC49">Packages</A></H1>



<H2><A NAME="SEC50" HREF="chpp.html#TOC50"><TT>`files.chh'</TT></A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>frest</B> <I>(<VAR>file</VAR>)</I>
<DD><A NAME="IDX72"></A>
Returns the not yet read contents of the file associated with the handle
<VAR>file</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>fwholefile</B> <I>(<VAR>filename</VAR>)</I>
<DD><A NAME="IDX73"></A>
Returns the whole contents of the file with the name <VAR>filename</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>fneweras</B> <I>(<VAR>filename1</VAR>,<VAR>filename2</VAR>)</I>
<DD><A NAME="IDX74"></A>
Returns <CODE>1</CODE> if the modification time of the file with name
<VAR>filename1</VAR> is more recent than that of the file with name
<VAR>filename2</VAR> or if the file with name <VAR>filename2</VAR> does not
exist. Returns <VAR>0</VAR> otherwise.
</DL>

</P>


<H2><A NAME="SEC51" HREF="chpp.html#TOC51"><TT>`strings.chh'</TT></A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>replacesubstring</B> <I>(<VAR>string</VAR>,<VAR>start</VAR>,<VAR>length</VAR>,<VAR>replacement</VAR>)</I>
<DD><A NAME="IDX75"></A>
Returns a string resulting from replacing the substring starting at
index <VAR>start</VAR> with length <VAR>length</VAR> of <VAR>string</VAR> by the string
<VAR>replacement</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>strneq</B> <I>(<VAR>string1</VAR>,<VAR>string2</VAR>)</I>
<DD><A NAME="IDX76"></A>
Returns a boolean value of TRUE if <VAR>string1</VAR> and <VAR>string2</VAR> are
not equal, otherwise TRUE.
</DL>

</P>


<H2><A NAME="SEC52" HREF="chpp.html#TOC52"><TT>`list.chh'</TT></A></H2>

<P>
<DL>
<DT><U>Macro:</U> <B>listSearch</B> <I>(<VAR>list</VAR>,<VAR>criterion</VAR>)</I>
<DD><A NAME="IDX77"></A>
Returns the index of the first element of <VAR>list</VAR> for which the
closure <VAR>criterion</VAR>, when called with that element as parameter,
evaluates to boolean TRUE. Example

</P>

<PRE>
%listSearch(%list(a,bb,ccc,dddd),%lambda(e,%[%slength(%e)&#62;=3]))
=> 2
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>listIndexOf</B> <I>(<VAR>list</VAR>,<VAR>value</VAR>)</I>
<DD><A NAME="IDX78"></A>
Returns the index of the first element of <VAR>list</VAR> which is
<CODE>equal</CODE> to <VAR>value</VAR>. Example:

</P>

<PRE>
%listIndexOf(%list(a,b,c,d),b)
=> 1
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>listMap</B> <I>(<VAR>mapping</VAR>,<VAR>list</VAR>[,<VAR>list</VAR>...])</I>
<DD><A NAME="IDX79"></A>
All <VAR>list</VAR>s must have the same length, and <VAR>mapping</VAR> must be a
closure taking as many arguments as there are
<VAR>list</VAR>s. <CODE>listMap</CODE> creates a new list by applying <VAR>mapping</VAR>
element-wise to the elements of the <VAR>list</VAR>s and storing the results
in the corresponding elements of the resulting list. Example:

</P>

<PRE>
%listMap(%lambda(a,b,%[a+b]),%list(2,5,7),%list(4,2,9))
=> %list(%'6',%'7',%'16')
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>listLeftAccumulate</B> <I>(<VAR>accumulator</VAR>,<VAR>list</VAR>,<VAR>zero</VAR>)</I>
<DD><A NAME="IDX80"></A>
If the length of <VAR>list</VAR> is <CODE>0</CODE>, returns <VAR>zero</VAR>. Otherwise,
accumulates all elements of <VAR>list</VAR> through <VAR>accumulator</VAR>, which
must be a closure taking two arguments, in a left-associative
way. Examples:

</P>

<PRE>
%listLeftAccumulate(%lambda(a,b,%[a+b]),%list(1,2,3),0)
=> 6
%listLeftAccumulate(%lambda(a,b,acc%'('%a%','%b%')'),
                    %list(a,b,c),zero)
=> acc(acc(a,b),c)
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>listRightAccumulate</B> <I>(<VAR>accumulator</VAR>,<VAR>list</VAR>,<VAR>zero</VAR>)</I>
<DD><A NAME="IDX81"></A>
If the length of <VAR>list</VAR> is <CODE>0</CODE>, returns <VAR>zero</VAR>. Otherwise,
accumulates all elements of <VAR>list</VAR> through <VAR>accumulator</VAR>, which
must be a closure taking two arguments, in a right-associative
way. Examples:

</P>

<PRE>
%listRightAccumulate(%lambda(a,b,acc%'('%a%','%b%')'),
                     %list(a,b,c),zero)
=> acc(a,acc(b,c))
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>listJoin</B> <I>(<VAR>string</VAR>,<VAR>list</VAR>)</I>
<DD><A NAME="IDX82"></A>
Joins the elements of the list <VAR>list</VAR> by inserting between two
sequential elements the string <VAR>string</VAR>. Example:

</P>

<PRE>
%listJoin(:,%list(the,quick,brown,fox))
=> the:quick:brown:fox
</PRE>

</DL>



<H2><A NAME="SEC53" HREF="chpp.html#TOC53"><TT>`time.chh'</TT></A></H2>

<P>
Time values are represented in <CODE>chpp</CODE> by hashes containing values
for some of the following keys:

</P>
<DL COMPACT>

<DT><CODE>year</CODE>
<DD>
<DT><CODE>month</CODE>
<DD>
<DT><CODE>day</CODE>
<DD>
<DT><CODE>hour</CODE>
<DD>
<DT><CODE>minute</CODE>
<DD>
<DT><CODE>second</CODE>
<DD>
</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>timeToString</B> <I>(<VAR>format</VAR>,<VAR>time</VAR>)</I>
<DD><A NAME="IDX83"></A>
Converts a time value to a string according to the format string
<VAR>format</VAR>. Ordinary characters in <VAR>format</VAR> are copied verbatim,
while the dollar character (<CODE>$</CODE>), followed by any of the following
characters is treated specially:

</P>
<DL COMPACT>

<DT><CODE>$</CODE>
<DD>
The character <CODE>$</CODE>.
<DT><CODE>d</CODE>
<DD>
The day of the month as a decimal number, beginning with <CODE>1</CODE> for
the first day of the month.
<DT><CODE>m</CODE>
<DD>
The month as a decimal number, beginning with <CODE>1</CODE> for January.
<DT><CODE>b</CODE>
<DD>
The abbreviated month name.
<DT><CODE>B</CODE>
<DD>
The full month name.
<DT><CODE>Y</CODE>
<DD>
The year as a decimal number.
<DT><CODE>H</CODE>
<DD>
The hour as a decimal number (range <CODE>0</CODE> to <CODE>23</CODE>).
<DT><CODE>M</CODE>
<DD>
The minute as a decimal number (range <CODE>0</CODE> to <CODE>59</CODE>).
<DT><CODE>S</CODE>
<DD>
The second as a decimal number (range <CODE>0</CODE> to <CODE>59</CODE>).
</DL>

<P>
Example:

</P>

<PRE>
%timeToString($d $B $Y,%hash(day,29,month,12,year,1975))
=> 29 December 1975
</PRE>

</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>timeFromString</B> <I>(<VAR>format</VAR>,<VAR>string</VAR>)</I>
<DD><A NAME="IDX84"></A>
Converts the string <VAR>string</VAR>, which must obey the time format
<VAR>format</VAR>, as described above, to a time value. Example:

</P>

<PRE>
%encode(%timeFromString($d $B $Y,29 December 1975))
=> %hash(%'year',%'1975',%'day',%'29',%'month',%'12')
</PRE>

</DL>



<H2><A NAME="SEC54" HREF="chpp.html#TOC54"><TT>`sql.chh'</TT></A></H2>

<P>
This section describes <CODE>chpp</CODE>'s interface to relational databases,
called <CODE>chdbc</CODE> (<CODE>chpp</CODE> Database Connectivity). The interface
is a layer above the client libraries for the various database servers,
making it thus transparent to the user which database she is using.

</P>
<P>
Connections and results are represented by abstract datatypes. When
passing a connection or result to a <CODE>chdbc</CODE> macro, do always pass
the value which was returned by the creating macro, not a copy (i.e. use
the reference form of variable access (see section <A HREF="chpp.html#SEC30">Accessing Variables</A>) to
pass connection and result parameters).

</P>
<P>
Drivers are currently implemented for mSQL and MySQL. The latter takes
a connection hash with keys <CODE>user</CODE> and <CODE>password</CODE>.

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>sqlConnect</B> <I>(<VAR>url</VAR>,<VAR>hash</VAR>)</I>
<DD><A NAME="IDX85"></A>
Opens a connection to the SQL Server with the given <VAR>url</VAR>, which
needs to be of the form
<CODE>chdbc:</CODE><VAR>drivername</VAR><CODE>://</CODE><VAR>hostname</VAR>[<CODE>:</CODE><VAR>port</VAR>]<CODE>/</CODE><VAR>dbname</VAR><CODE>/</CODE>. A
valid example would be <CODE>chdbc:mysql://localhost/test/</CODE>. <VAR>hash</VAR>
must be hash containing information required by the driver to connect to
the server, e.g. username and password. <CODE>sqlConnect</CODE> returns a
value representing the connection to the server or a boolean value of
FALSE if the connection could not be made.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>sqlClose</B> <I>(<VAR>connection</VAR>)</I>
<DD><A NAME="IDX86"></A>
Closes the database connection <VAR>connection</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>sqlDatabaseInfo</B> <I>(<VAR>connection</VAR>)</I>
<DD><A NAME="IDX87"></A>
Returns a hash containing information about the database. The hash
contains values for the following keys, if appropriate for the database:

</P>
<DL COMPACT>

<DT><CODE>timeformat</CODE>
<DD>
Format for time values which can be used in inserts and updates, like
<CODE>$H:$M:$S</CODE>.

<DT><CODE>dateformat</CODE>
<DD>
Format for date values which can be used in inserts and updates, like
<CODE>$Y-$m-$d</CODE>.

<DT><CODE>datetimeformat</CODE>
<DD>
Format for time plus date values which can be used in inserts and
updates, like <CODE>$Y-$m-$d $H:$M:$S</CODE>.
</DL>
</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>sqlQuery</B> <I>(<VAR>connection</VAR>,<VAR>querystring</VAR>)</I>
<DD><A NAME="IDX88"></A>
Performs a query on the database connected to by
<VAR>connection</VAR>. Returns a value representing the result of the query
or a boolean value of FALSE if the query could not be executed.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>sqlResultData</B> <I>(<VAR>result</VAR>)</I>
<DD><A NAME="IDX89"></A>
Returns the result rows of the query result <VAR>result</VAR>, as obtained by
<CODE>sqlQuery</CODE>, in the form of a list. Each row in this list is
represented as a hash whose keys are the column names of the
result. Values for columns representing time (<CODE>time</CODE>, <CODE>date</CODE>
and <CODE>datetime</CODE>) are automatically converted to <CODE>chpp</CODE>'s time
format (see section <A HREF="chpp.html#SEC53"><TT>`time.chh'</TT></A>).
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>sqlResultColumnInfo</B> <I>(<VAR>result</VAR>)</I>
<DD><A NAME="IDX90"></A>
Returns a hash indexed by the column names of the query result
<VAR>result</VAR> containing information about the columns. Each value
contained in the hash is a hash containing values for the following
keys:

</P>
<DL COMPACT>

<DT><CODE>type</CODE>
<DD>
Type of the column.
</DL>
</DL>

<P>
<DL>
<DT><U>Macro:</U> <B>sqlResultColumnNames</B> <I>(<VAR>result</VAR>)</I>
<DD><A NAME="IDX91"></A>
Returns a list containing the names of the column of the query result
<VAR>result</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>sqlUpdate</B> <I>(<VAR>connection</VAR>,<VAR>updatestring</VAR>)</I>
<DD><A NAME="IDX92"></A>
Performs an SQL statement contained in the string <VAR>updatestring</VAR>
changing the data of the database connected to by <VAR>connection</VAR>, like
an insert or an update.
</DL>

</P>


<H2><A NAME="SEC55" HREF="chpp.html#TOC55"><TT>`cgi.chh'</TT></A></H2>

<P>
The package <TT>`cgi.chh'</TT> provides rudimentary support for
CGI scripting.

</P>
<P>
<DL>
<DT><U>Macro:</U> <B>cgiGetParameters</B> <I>()</I>
<DD><A NAME="IDX93"></A>
Returns a hash containing all parameters passed to the CGI
script. Supported encodings are <CODE>application/x-www-form-urlencoded</CODE>
(both <CODE>GET</CODE> and <CODE>POST</CODE>) and <CODE>multipart/form-data</CODE>.
</DL>

</P>



<H1><A NAME="SEC56" HREF="chpp.html#TOC56">Macro Index</A></H1>

<P>
<H2>a</H2>
<DIR>
<LI><A HREF="chpp.html#IDX21">and</A>
<LI><A HREF="chpp.html#IDX64">apply</A>
</DIR>
<H2>b</H2>
<DIR>
<LI><A HREF="chpp.html#IDX63">bound</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="chpp.html#IDX13">case</A>
<LI><A HREF="chpp.html#IDX93">cgiGetParameters</A>
<LI><A HREF="chpp.html#IDX12">cond</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="chpp.html#IDX2">define</A>, <A HREF="chpp.html#IDX23">define</A>
<LI><A HREF="chpp.html#IDX55">depend</A>
<LI><A HREF="chpp.html#IDX10">disc</A>
<LI><A HREF="chpp.html#IDX9">discard</A>
<LI><A HREF="chpp.html#IDX20">dountil</A>
<LI><A HREF="chpp.html#IDX19">dowhile</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="chpp.html#IDX58">encode</A>
<LI><A HREF="chpp.html#IDX61">equal</A>
<LI><A HREF="chpp.html#IDX8">error</A>, <A HREF="chpp.html#IDX57">error</A>
</DIR>
<H2>f</H2>
<DIR>
<LI><A HREF="chpp.html#IDX38">fclose</A>
<LI><A HREF="chpp.html#IDX41">feof</A>
<LI><A HREF="chpp.html#IDX39">fgets</A>
<LI><A HREF="chpp.html#IDX74">fneweras</A>
<LI><A HREF="chpp.html#IDX36">fopen</A>
<LI><A HREF="chpp.html#IDX14">for</A>
<LI><A HREF="chpp.html#IDX15">foreach</A>
<LI><A HREF="chpp.html#IDX16">foreachkey</A>
<LI><A HREF="chpp.html#IDX37">fpipe</A>
<LI><A HREF="chpp.html#IDX40">fputs</A>
<LI><A HREF="chpp.html#IDX72">frest</A>
<LI><A HREF="chpp.html#IDX42">fstat</A>
<LI><A HREF="chpp.html#IDX73">fwholefile</A>
</DIR>
<H2>h</H2>
<DIR>
<LI><A HREF="chpp.html#IDX32">hash</A>
<LI><A HREF="chpp.html#IDX34">hcontains</A>
<LI><A HREF="chpp.html#IDX33">hcount</A>
<LI><A HREF="chpp.html#IDX35">hkeys</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="chpp.html#IDX3">if</A>, <A HREF="chpp.html#IDX11">if</A>
<LI><A HREF="chpp.html#IDX5">ifdef</A>
<LI><A HREF="chpp.html#IDX4">ifdefined</A>
<LI><A HREF="chpp.html#IDX7">ifndef</A>
<LI><A HREF="chpp.html#IDX6">ifnotdefined</A>
<LI><A HREF="chpp.html#IDX1">include</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="chpp.html#IDX30">lappend</A>
<LI><A HREF="chpp.html#IDX28">ldelete</A>
<LI><A HREF="chpp.html#IDX27">linsert</A>
<LI><A HREF="chpp.html#IDX25">list</A>
<LI><A HREF="chpp.html#IDX78">listIndexOf</A>
<LI><A HREF="chpp.html#IDX82">listJoin</A>
<LI><A HREF="chpp.html#IDX80">listLeftAccumulate</A>
<LI><A HREF="chpp.html#IDX79">listMap</A>
<LI><A HREF="chpp.html#IDX81">listRightAccumulate</A>
<LI><A HREF="chpp.html#IDX77">listSearch</A>
<LI><A HREF="chpp.html#IDX26">llength</A>
<LI><A HREF="chpp.html#IDX24">locals</A>
<LI><A HREF="chpp.html#IDX29">lsort</A>
<LI><A HREF="chpp.html#IDX31">luniq</A>
</DIR>
<H2>n</H2>
<DIR>
<LI><A HREF="chpp.html#IDX65">not</A>
</DIR>
<H2>o</H2>
<DIR>
<LI><A HREF="chpp.html#IDX22">or</A>
<LI><A HREF="chpp.html#IDX54">outputenable</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="chpp.html#IDX59">random</A>
<LI><A HREF="chpp.html#IDX75">replacesubstring</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="chpp.html#IDX60">same</A>
<LI><A HREF="chpp.html#IDX51">schr</A>
<LI><A HREF="chpp.html#IDX50">scmp</A>
<LI><A HREF="chpp.html#IDX46">sgsub</A>
<LI><A HREF="chpp.html#IDX67">shexdecode</A>
<LI><A HREF="chpp.html#IDX66">shexencode</A>
<LI><A HREF="chpp.html#IDX48">slength</A>
<LI><A HREF="chpp.html#IDX43">smatch</A>
<LI><A HREF="chpp.html#IDX52">snumber</A>
<LI><A HREF="chpp.html#IDX86">sqlClose</A>
<LI><A HREF="chpp.html#IDX85">sqlConnect</A>
<LI><A HREF="chpp.html#IDX87">sqlDatabaseInfo</A>
<LI><A HREF="chpp.html#IDX88">sqlQuery</A>
<LI><A HREF="chpp.html#IDX90">sqlResultColumnInfo</A>
<LI><A HREF="chpp.html#IDX91">sqlResultColumnNames</A>
<LI><A HREF="chpp.html#IDX89">sqlResultData</A>
<LI><A HREF="chpp.html#IDX92">sqlUpdate</A>
<LI><A HREF="chpp.html#IDX47">sremovews</A>
<LI><A HREF="chpp.html#IDX44">ssplit</A>
<LI><A HREF="chpp.html#IDX49">ssub</A>
<LI><A HREF="chpp.html#IDX45">stokenize</A>
<LI><A HREF="chpp.html#IDX76">strneq</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="chpp.html#IDX84">timeFromString</A>
<LI><A HREF="chpp.html#IDX83">timeToString</A>
<LI><A HREF="chpp.html#IDX62">typeof</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="chpp.html#IDX18">until</A>
</DIR>
<H2>v</H2>
<DIR>
<LI><A HREF="chpp.html#IDX53">void</A>
</DIR>
<H2>w</H2>
<DIR>
<LI><A HREF="chpp.html#IDX56">warning</A>
<LI><A HREF="chpp.html#IDX17">while</A>
</DIR>

</P>

<P><HR><P>
This document was generated on 30 April 1998 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51.</P>
</BODY>
</HTML>
