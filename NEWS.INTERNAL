-*- outline -*-

* schani, 17.7.1997

** dsEmpty()

es gibt jetzt eine funktion namens dsEmpty(), die einen leeren
dynstring zurueckgibt.  dieser ist statisch und darft nicht veraendert
oder gefreed werden.

** makroaufrufe mit und ohne <>

wenn man ohne '<>' ein makro verwendes, dass nicht gibt, wird einfach
der string eingesetzt, den man verwendet, also %ruelps ergibt %ruelps,
wenn ruelps nicht definiert ist. wenn man aber %<ruelps> eingibt, gibt
er eine fehlermeldung aus.

** \n und \t in strings

man kann in strings jetzt auch \n und \t verwenden.

** ich hab die ganze testscheisse ins test-verzeichnis gemoved.

** issueWarning() und issueError()

es gibt jetzt die funktionen issueWarning() und issueError(), mit der
man errors und warnings ausgeben kann. im error.c sind die texte fuer
die meldungen definiert und in error.h symbolische konstanten fuer die
nummern. warnings und errors aus deinem teil muessen die nummern
1000-1999 haben, die aus meinem 2000-2999.

** Makefile

ich hab das haupt-Makefile umgestellt. wichtigste aenderung:
dependencies werden automatisch generiert. einfach make depend
eingeben.

** website-test

ich hab ein groesseres testding gemacht, um reelle situationen zu
testen. liegt in test/website. sowas geht ur-supa min chakotay.

* schani, 18.7.1997, ganz frueh in da nacht (01:00)

** die arithmetischen expressions evaluaten schon!

* schani, 18.7.1997, frueher nachmittag

** XEmacs auf Rhapsody?

ich hab heute getraeumt, das apple in der entwicklungsumgebung fuer
Rhapsody einen auf OpenStep geporteten XEmacs mitliefern
wird... seltsam...

** locals

es gibt jetzt ein locals makro, mit dem man lokale variablen
deklarieren kann. syntax ist wie folgt:

  %locals(x,y,z,...,expr)

dabei werden die lokalen variablen x,y,z,... deklariert und mit ihnen
expr evaluiert. also zum beispiel:

  %define(a,x)
  %locals(a,%define(a,y)a=%a)
  a=%a

ergibt

  a=y
  a=x

verwendungszweck ist in erster linie user-defined makros, die lokale
variablen brauchen.

** fakultaet

hab einige fehler ausgebessert. probier mal folgendes:

  #define fak(x)              %if(%[%x==1],1,%[%x*%fak(%[%x-1])])
  %fak(6)

leiwand, gell?

** makros in mathematischen ausdruecken

ich ueberlege mir gerade, ob es nicht vernuenftig waere, innerhalb von
mathematischen ausdruecken das metazeichen fuer makros wegzulassen
(bzw das weglassen zu erlauben), sodass man die fakultaet zum beispiel
so implementieren kann:

  #define fak(x)         %[if(x==1,1,fak(x-1))]

ist uebersichtlicher und wesentlich einfacher, ausserdem effizienter
zu evaluieren.  natuerlich waere die voll ausgeschriebene methode
immer noch erlaubt.

*** makros in mathematischen ausdruecken II

mir ist grad eingefallen, dass das fuer parametrisierte makros
scheisse ist, weil wenn ich das in meine arithmetik aufnehmen wuerde,
muesste ich alle parameter evaluieren, bevor ich das makro aufrufe,
was zum beispiel beim obigen if probleme machen wuerde, da der
else-ausdruck ausgewertet wuerde, egal, ob x==1 ist oder nicht, ergo
endlose rekursion. ich werds also momentan auf variablen beschraenken,
also

  #define fak(x)         %if(%[x==1],1,%[x*%fak(%[x-1])])

vielleicht faellt mir ja was noch was besseres ein...

*** ich habs jetzt fuer die variablen implementiert. funkt ganz gut.

** main()

ich hab die main-funktion komplett ueberarbeitet. sie funkt jetzt mit
GNU getopt_long.  optionen sind --help, --version, --output=<ofile>
oder -o <ofile>, -D<name>[=<value].  auch kann man mehrere input-files
angeben, die sequentiell abgearbeitet werden.  standardmaessig liest
er von stdin und schreibt auf stdout.

* schani, 19.7.1997, ur frueh in da nacht (00:18)

** ifdef

ich hab jetzt ein ifdef makro geschrieben. funkt ur
straightforward. lass dir mal folgendes durch den kopf gehen (ich
hoffe, du kennst die fibonacci-folge):

  #define fib(x)              %ifdef(fib_%x,%{%%fib_%x},%define(fib_%x,%[%fib(%[x-1])+%fib(%[x-2])])%{%%fib_%x})
  #define fib_1               1
  #define fib_2               1
  fib(30) = %fib(30)

wennst das komplett rekursiv implementiert haettest, braeuchte das
ur-lang.

** memory leaks und dynstrings

da meine routinen (noch) keine dynstrings freigeben, braucht der
chakotay zuweilen (insbes bei rekursiven sachen) ur-viel speicher. ich
hab ausprobiert mit obigem makro die 200ste fibonacci zahl
auszurechnen, was nicht nur ur-lang gedauert hat, sondern auch 23megs
speicher verbraten hat. ich hab jetzt die dynstrings so umgestellt,
dass sie standardmaessig nur 64 byte allokieren (1024 waren doch ein
bisserl zuviel), dafuer aber immer auf das doppelte anwachsen, wenn
sie zu klein werden. nicht nur hat die berechnung jetzt viel weniger
speicher gebraucht, sie war auch viel schneller.

* schani, 19.7.1997, frueher nachmittag

** memory leaks gestopft

ich glaub, ich hab jetzt so ziemlich alle meine memory-leaks
gestopft. zumindest berechnet er nunmehr die 30ste fibonacci-zahl mit
komplett rekursivem algorithmus (kurdisch) mit konstant 472kb
vmsize. nicht, dass er jemals damit fertig werden wuerde, aber
immerhin. heute zu mittag hatte ich noch ein leak von ca 2megs pro
sekunde :-)

* schani, 20.7.1997, frueher nachmittag

** regexps

das regexp matchen funkt schon. das makro match matched das erste
argument gegen das zweite, also zum beispiel:

  %match([^/]+$,/heinzi/deinzi/test.jpg)

matched 'test.jpg', gibt aber 15 zurueck, weil dort der match
begann. ich werd auf jeden fall einbauen, dass er sich die register
merkt, also dass zum beispiel nach

  %match(%"([^/]+)$",/heinzi/deinzi/test.jpg)

%1 auf 'test.jpg' gesetzt wird. ausserdem werd ich wahrscheinlich
einbauen, dass dann %0 auf den kompletten gematchten string gesetzt
wird.

** regexp register

ich habs:

  %if(%[%match([^/]+$,/heinzi/deinzi/test.jpg)!=-1],%0)

ergibt 'test.jpg'.

** void

aus gruenden habe ich ein void makro geschrieben, das nichts anderes
macht, als sein argument auszuwerten und einen leerstring
zurueckzugeben. man kann also obigen match geschickter so schreiben:

  %void(%match([^/]+$,/heinzi/deinzi/test.jpg))%0

** loop-makros

ich hab vier neue loop-konstrukte eingefuehrt. folgendes beispiel
illustriert sie wohl am besten:

  #define i 0
  while : %while(%[i<10],%i %define(i,%[i+1]))
  #define i 0
  until : %until(%[i>=10],%i %define(i,%[i+1]))
  #define i 0
  dowhile : %dowhile(%i %define(i,%[i+1]),%[i<10])
  #define i 0
  dountil : %dountil(%i %define(i,%[i+1]),%[i>=10])

alle vier zaehlen von 0 bis 9.

** file-handling

ich hab file-handling eingefuert. folgende makros gibts:

  %open(heinzi.deinzi)

oeffnet das file 'heinzi.deinzi' zum lesen und gibt einen
identifizierenden string zurueck (tatsaechlich ist es eine zahl, aber
nicht der fd) oder '-1' wenn die datei nicht geoeffnet werden
kann. ich werde noch irgendwann einbauen, dass man (am besten so wie
bei fopen) dateien auch zum schreiben und so oeffnen kann, aber im
moment reicht das.

  %close(%file)

schliesst das file %file.

  %eof(%file)

gibt '1' zurueck, wenn das file eof ist, anderenfalls '0'.

  %readline(%file)

liest aus dem file eine zeile und gibt diese zurueck
(inkl. abschliessendem newline, wenn es noch gelesen wurde (was nur
beim ende der datei nicht der fall ist)).

zur illustration gibts noch ein beispiel. dieses programm gibt einfach
nur den inhalt der datei test.data aus:

  %define(file,%open(test.data))
  %dountil(%readline(%file),%eof(%file))
  %close(%file)

jetzt weisst du auch, warums die 'until' scheisse gibt. wenn nicht
muesste ich schreiben

  %dowhile(%readline(%file),%[!%eof(%file)])

und das schaut irgendwie grindig aus.

** Makefile

ich hab wieder das Makefile ein bisserl umgestellt, weil ich die
builtins in mehrere files aufgesplittet und in ein eigenes verzeichnis
gestellt hab (wer haett sich wohl gedacht, dass ich das builtins
genannt hab?). ich verwend jetzt das VPATH feature vom gnumake.
deshalb brauchen wir jetzt auch keine sub-makefiles mehr. bis auf
deinen privaten
 testbetrieb ist also emp/Makefile eigentlich unnoetig.

** TODO-file

neue konvention fuers TODO file: wenn ein punkt erledigt ist, bitte
nicht loeschen, sondern ein steandal (asterix) aus dem plus machen.

** removews

neues makro: removews. removed die outeren whitespaces.

  "%removews(    %"     heinzi     "   )"

ergibt "heinzi".

** pipe

neues makro: pipe, erlaubt es, einen child-prozess zu starten und
dessen output wie ein file zu behandeln. rueckgabewert wie
open. beispiel:

  %define(file,%pipe(ls))
  %dountil(%readline(%file),%eof(%file))
  %close(%file)

gibt das inhaltsverzeichnis des momentanen dirs aus.

* schani, 21.7.1997, frua in da frua (01:18)

** assoziative arrays

mir ist eingefallen, wie man assoziative arrays (hash tables) leicht
in den chakotay einfuegen koennte: die syntax ist die selbe wie von
parametrisierten makros, nur dass statt () [] verwendet wird. also zum
beispiel:

  %define(name[heinz],emperor)
  %define(name[mark],schani)

dann koennte man ganz einfach schreiben %name[heinz] (oder auch
%<name[heinz]>) und man bekaeme 'emperor'. ausserdem muesste man es so
implementieren, dass ein makro sowohl normale variable als auch array
sein koennte, je nachdem wies verwendet wird, also %name, %name[heinz]
und %name[mark] waeren eigentlich drei verschiedene variablen. das
macht zum beispiel lokale variablen einfacher, d.h. man deklariert a
als lokale variable und kann sie auch als array verwenden. das ganze
ist einfach zu implementieren, passt recht gut in die syntax rein und
wuerde ganz neue moeglichkeiten eroeffnen. ich werds jetzt allerdings
noch nicht implementieren. wir reden erst beim heribert drueber.

** substring

ich hab ein substring makro implementiert. funktionsweise wie folgt:
indizes beginnen bei 0.  das makro hat zwei formen:

  %substring(a,str)

wenn a nichtnegativ ist, werden alle zeichen ab zeichen mit index a
zurueckgegeben, anderenfalls alle zeichen bis exklusive das mit index
-a.

  %substring(a,b,str)

wenn b nichtnegativ ist, werden die ersten b zeichen ab index a
zurueckgegeben, anderenfalls alle zeichen angefangen mit index a bis
exklusive index -b.  beispiele:

  "%substring(1,3,0123456789)" = "123"
  "%substring(1,-3,0123456789)" = "12"
  "%substring(5,0123456789)" = "56789"
  "%substring(-5,0123456789)" = "01234"

** random

neues makro: random, erzeugt zufallszahl im intervall 0 und 2^31-1
wenn mich nicht alles taeuscht:

  %random

ergibt irgend eine zahl. geseeded wird im moment noch nix, is aber zum
testen eh besser.

** tautogen

heinz, wennst das siehst wird dir der arsch abfallen, so genial is
das! schau ins verzeichnis test/tautogen und start einfach einmal
tautogen.csml. mehr output kannst mit der -Dn=<x> als command-line
option erzeugen (-Dn=100 ist empfehlenswert). tautogen_c.csml ist
(etwas) dokumentiert. data enthaelt die 'rohdaten'. schau, dasst bis
zur party vom herbert noch ein bisserl ins data dazuschreibst, das
wird dann der partyhit.

bist du deppat, der chakotay und i san supa!

heinz, mein kompliment: das chakotay-konzept is voll aufgegangen. er
rult einfach unwahrscheinlich. hast dir gut ausgedacht, da gibts nix.

btw: zeig die scheisse einmal dem meller und insbes auch dem ed. wuerd
mich interessieren, was die dazu sagen.

* schani, 21.7.1997, frueher nachmittag

** strlength

neues makro: strlength, gibt die laenge eines strings zurueck.

  %strlength(heinzi deinzi)

ergibt '13'.

** builtins/Makefile

ich hab im builtins-verzeichnis ein Makefile gemacht, dass nichts
anderes macht, als make im top-verzeichnis aufzurufen. ist praktisch,
wenn man aus dem emacs raus kompilieren will.

* schani, 22.7.1997, in da frua

** towers of hanoi

als antwort auf m4's demo hab ich auch ein towers of hanoi
implementiert. zu finden in test/hanoi.txt.

** umstellungen

ich hab mir ueberlegt, dass ich bei mir wieder einiges umstellen muss,
insbesondere den output-teil. momentan ist es so, dass wenn irgendwo
geschachtelt eine ausgabe passiert, also zum beispiel

  %for(i,1,10,%i%" ")

dass dann nicht jedes %i%" " einzeln ausgegeben wird, sondern alle in
einem dynstring akkumuliert werden und erst dann ausgegeben. das hat
zwei nachteile: einerseits, dass der benutzer nicht sofort die ausgabe
sieht (bei laengeren schleifen von nachteil) und andererseits, und das
ist wichtiger, dass in manchen faellen viel zu viel speicher
verschenkt wird, indem viel zu viele dynstrings nur benutzt werden, um
ausgabe zu akkumulieren.

* schani, 24.7.1997, nachmittag

** OPENSTEP

ich hab den chakotay unter OPENSTEP ausprobiert. bis auf ein paar
kleine anpassungen im source ist es eigentlich problemlos
gelaufen. ausserdem hab ich das Makefile wieder geandert: es gibt
jetzt ein Makefile.linux und ein Makefile.next. ausserdem gibts ein
Makefile.common, dort stehen die gemeinsamkeiten drin. mit dem
shell-script configure kann man einen symlink vom gewuenschten
makefile auf Makefile machen. unter OPENSTEP muss man mit 'gnumake'
maken.

* schani, 28.7.1997, nachmittag

** warnings und errors

ich hab jetzt issueError() und issueWarning() so umgestellt, dass sie
varags nehmen.  du kannst also jetzt deine errors und warnings im
error.[ch] eintragen und welches printf format auch immer
verwenden. damitst dich nicht aufregst, hab ich gleich alle deine
warnings und errors konvertiert, ergo, du brauchst nur mehr die
eintragen, die neu dazukommen.

irgendwann werd ich auch noch einbauen, dass er auch die
include-hierarchie ausgibt.

** newline ausremen

man kann jetzt newlines mit \ ausremen. paradebeispiel: der jetzt
richtig uebersichtlich aussehende tautogen.

* schani, 30.7.1997, in da nacht

** optimierungen

interessanterweise scheint es gar nicht so leicht, den chakotay zu
optimieren. trotz einiger bemuehungen (symboltable mit hashtable,
dynstring-allokation, ausgabe) ist es mit nicht gelungen, den chpp
nennenswert schneller zu machen.

folgende werte ergaben sich mit der neuen speedsuite (test/speedsuite)
vor den optimierungen:

-- fibonacci
7.49user 0.01system 0:07.51elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
-- hanoi
5.29user 0.04system 0:05.33elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
-- tautogen
7.41user 0.07system 0:07.48elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k

und nachher:

-- fibonacci
6.09user 0.01system 0:06.09elapsed 100%CPU (0avgtext+0avgdata 0maxresident)k
-- hanoi
3.48user 0.10system 0:03.58elapsed 100%CPU (0avgtext+0avgdata 0maxresident)k
-- tautogen
5.30user 0.10system 0:05.40elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k

ich werd noch irgendwann einen test einbauen, der ein grosses
eingabefile verbatim (da ohne makros) kopiert.

** process overflow???

ich nehme einmal an, dass das fprintf im processOverflow() eine
debug-meldung und keine fehlermeldung sein soll. ich kommentiers aus.

** verbatim performance

in der verbatim-performance stehen wir gar nicht so schlecht da. der
chpp braucht fuer ein 200k grosses file lediglich 0.33s (user time),
was bedeutet, wir haben eine verbatim-performance von 600k pro
sekunde, was fuer so ziemlich alle anwendungen reichen sollte.

** fehler in fillBuffer

versuch einmal test/speedsuite/tnglogbk.txt durch den chpp laufen zu
lassen und vergleich das ergebnis mit dem original. theoretisch
muessten die beiden files gleich sein. der fehler liegt im
fillBuffer. um das besser testen zu koennen, hab ich die commandline
option --test-fillbuffer implementiert, die nix anderes macht, als
statt den ganzen eval prozess zu durchlaufen, das eingabefile nur
durch fillBuffer haut und das ergebnis ausgibt.

* schani, 30.7.1997, nachmittag

** optimierungen und builtins

ich hab jetzt wieder was optimiert. ergebnis:

-- fibonacci
5.15user 0.02system 0:05.17elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
-- hanoi
3.06user 0.08system 0:03.16elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
-- tautogen
3.11user 0.01system 0:03.13elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k

im grossen und ganzen ist der chpp jetzt doppelt so schnell wie
frueher. offen gestanden faellt mir eigentlich nix mehr ein, wo ich
noch was merkbares an performance rausholen koennte.

kleiner nebeneffekt der optimierung: das interface zu den builtins hat
sich ein bisserl geaendert. die funktion defineGlobalBuiltIn() hat
jetzt einen drittern parameter evalParams, der angibt, ob die
parameter des builtins automatisch von WS gestrippt und geevaled
werden sollen. fuer die builtins, wo das so ist, machts die sache
bisserl effizienter und ausserdem unkomplizierter.

** -O3

ich hab einmal mit -O3 kompiliert. ergebnis:

-- fibonacci
4.10user 0.02system 0:04.28elapsed 96%CPU (0avgtext+0avgdata 0maxresident)k
-- hanoi
2.41user 0.03system 0:02.44elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
-- tautogen
2.31user 0.04system 0:02.42elapsed 97%CPU (0avgtext+0avgdata 0maxresident)k
-- tng log book
0.25user 0.02system 0:00.27elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k

irgendwann werd ich einmal profilen...

** assoziative arrays

ich habs implementiert. den tautogen hab ich auch schon
umgestellt. funkt praechtig.  beispiel:

  %adefine(tab,heinz,deinz)
  %adefine(tab,schani,banani)
  tab[heinz] = %tab[heinz]
  tab[schani] = %tab[schani]
  %adefine(tab,heinz,deinhart)
  tab[heinz] = %tab[heinz]

mehrdimensionale arrays gibts nicht, weil sie erstens schwer zu
implementieren und zweitens leicht zu faken sind. beispiel:

  %adefine(tab,1;1,bla)
  %adefine(tab,1;2,blu)

wenn du sie wirklich haben willst, muessen wir nochmal genauer drueber
reden.

* schani, 31.7.1997, nachmittag

** define fuer parametrisierte makros

ich hab jetzt endlich das define so umgestellt, dass man auch
parametrisierte makros definieren kann. beispiel:

%define(repl,str,s,l,ns,%substring(0,%s,%str)%ns%substring(%[%s+%l],%str))

** strcmp und streq

es gibt zwei neue makros: strcmp und streq. ersteres funkt genauso wie
strcmp() in C. streq testet zwei strings auch gleichheit und gibt 1
zurueck, wenn sie das sind, anderenfalls 0.

** undefineSymbol()

es gibt jetzt eine funktion undefineSymbol() (symtab.h), mit der man
ein symbol undefinieren kann. jetzt kannst du endlich dein #undef
command implementieren.

** regression test suite

es gibt jetzt regression tests. einfach nach test/regress cd'n und
dotest starten.  der rest geht automatisch.

um einen test einzufuegen muss man im regress verzeichnis ein
unterverzeichnis erstellen und in diesem ein file mit dem namen des
unterverzeichnisses und der endung .txt. ausserdem muessen dort die
files expected.out und expected.err stehen, die die erwartete stdout
und stderr ausgabe enthalten. dann muss noch der name des verzeichnis
im file regress/tests eingetragen werden.

* schani, 1.8.1997, nachmittag

** foreach

mit dem foreach makro kann man alle keys eines assoziativen arrays
durchgehen.  die reihenfolge ist nicht definiert. beispiel:

  %adefine(tab,heinz,deinhart)\
  %adefine(tab,mark,probst)\
  %foreach(key,tab,%key%"\n")\

gibt

  mark
  heinz

aus.

** listen

ich hab mir ueberlegt, ob es nicht klug waere, auch noch listen (oder
arrays oder nenns wie du willst) einzufuehren, die mit numerischen
indizes indiziert werden.  fuer die sollten wir dann die [] klammern
verwenden, und fuer die assoziativen arrays die {} klammern. dann
koennte man ur-coole sachen machen, zum beispiel strings in listen
splitten oder listen sortieren. zum beispiel

  %keys(tab,keys)%sort(keys)

das wuerde vom assoziativen array tab die keys in eine liste speichern
und diese dann sortieren.

dann sollten wir das foreach makro in foreachkey umbenennen und ein
foreach fuer die listen machen, sodass man schreiben kann

  %foreach(elem,list,%elem%"\n")

** assignment

wir koennten ur-leicht ein viel cooleres assignment einbauen, mit dem
man eigentlich alle sachen assignen kann (makros, parametrisierte
makros, elemente von listen und assoziativen arrays): in der
%<>-notation sagt man einfach, dass, wenn nach dem makronamen ein =
kommt, der rechte teil zu assignen ist, z.b:

  %<heinzi=deinzi>
  %<makro(a,b,c)=%c%b%a>
  %<list[1]=xyz>
  %<tab{a}=b>

was meinst?

** ifdefkey

das makro ifdefkey checkt, ob ein gegebener key in ein assoziatives
array eingetragen ist.

  %ifdefkey(tab,heinz,heinz gibts,heinz gibts nicht)

* schani, 5.8.1997, frueh in da frueh

** outputenabled

neue interne variable. man kann ihr einen false-wert zuweisen, dann
wird die ausgabe unterbunden, bei einem true-wert wird ausgegeben.

  das kommt
  %<outputenabled=0>\
  das nicht
  %<outputenabled=1>\
  das schon

ergibt

  das kommt
  das schon

* schani, 8.8.1997, in da fruehen nacht

** neue assignment-syntax

die neue assignment-syntax funktioniert jetzt bereits fuer makros und
hashes.  parametrisierte makros funken noch nicht.

* schani, 8.8.1997, nachmittag

** arrays

arrays funken schon, allerdings im moment nur mit der <>
syntax. beispiel:

  %for(i,0,9,%<arr[%i]=%i>)\
  %for(i,0,9,arr[%i]=%<arr[%i]>%"\n")

** arrays funken auch schon mit der <>-losen syntax

* schani, 15.8.1997, in da nacht, ganz frueh

** embedded chakotay

mir ist eingefallen, dass wir den chakotay embeddable machen sollten.
dann koennte ich den chakotay zum beispiel in den YaHe einbauen, und
man kann gleich chakoten und den html-text previewen. ausserdem waere
das eine vorbereitung fuer das einbauen als modul in den apache.

als erstes brauch ich dazu die moeglichkeit, dem filler zu sagen, dass
er nicht aus einer datei, sondern von einem file descriptor lesen soll.
sollte ja keine challenge sein.

wenn man das weiterdenkt, sollten wir auch schoen langsam damit
anfangen, unseren code reentrant zu machen, damit man den chakotay
auch in threads laufen lassen kann. ich weiss, das ist eine
scheiss-hacken, aber eine investition in die zukunft. insbesondere
sollten wir davon absehen, ab jetzt irgendwas zu programmieren, was
man nur ur-schwer reentrant machen kann.

* schani, 16.8.1997, bevor der hahn kraeht

** arrlength und split

das makro arrlength gibt die laenge eines arrays zurueck. einziger
parameter ist der name des arrays (ohne %).

split splittet strings an den match-punkten von regexps:

  %split(aixaxixixixaxi,ixi|axi,arr)

gibt nichts zureck und setzt folgende element von arr:

  arr[0] = 'aix'
  arr[1] = 'x'
  arr[2] = 'x'
  arr[3] = ''

alle anderen element von arr werden geloescht, also

  %arrlength(arr) = 4

* schani, 16.8.1997, nachmittag

** sort

das makro sort sortiert ein array. einziges argument ist der name des
arrays. irgendwann werd ich noch einbauen, dass man noch zusaetzliche
optionen angeben kann (reverse, case-insensitive, ...)

** append

das makro append haengt an ein array ein element an. wenn a noch nicht
definiert ist, hat

  %append(a,1)
  %append(a,2)
  %append(a,3)

die seiteneffekte

  a[0] = 1
  a[1] = 2
  a[2] = 3

** foreach und foreachkey

ich hab jetzt foreach in foreachkey umbenannt. dafuer gibts jetzt ein
foreach, das auf arrays operiert. syntax dieselbe wie foreachkey, nur
das jetzt halt alle elemente des arrays durchlaufen werden.

** uniq

das uniq makro removed bei gleichen aufeinanderfolgenden
array-eintraegen alle bis auf einen. einziges argument ist der
array-name.

* schani, 13.12.1997, kurz nach mitternacht

** umstellung auf neues typsystem

ich hab jetzt alles so auf values umgestellt, dass der chpp zumindest
wieder das kann, was er vor der umstellung konnte, sprich die regress
tests laufen problemlos durch. verschachtelte strukturen funken noch
nicht.

** tests umgeschrieben

da ich das define-makro so umgeschrieben hab, dass man variablen damit
nicht mehr definen kann, weils eh schon die neue syntax gibt, hab ich
die tests auf die neue syntax umgestellt.

* schani, 13.12.1997, kurz vor mitternacht

** namenskonventionen

ich hab beschlossen, dass die assoziativen arrays offiziell hashes und
die arrays listen heissen werden, so wie auch im perl. die errors und
warnings hab ich schon dementsprechend geandert.

** anlegen von listen und hashes im neuen typsystem

aufgrund der besseren verstaendlichkeit und der klarheit, und nicht
zuletzt weils leichter zu implementieren ist, hab ich folgendes schema
fuers anlegen von listen und hashes erdacht:

es gibt zwei neue built-ins namens %list und %hash, welche jeweils
eine list und einen hash zurueckliefern. im moment sind dieses leere
datenstrukturen, ich werds aber einrichten, dass man auch schon
vorinitialisierte anlegen kann, also zum beispiel
%list(element1,element2), oder %hash(heinzi,deinzi,schani,banani)
(mapped heinzi auf deinzi und schani auf banani).

wenn man jetzt eine list %heinz haben will, muss ma machen

  %<heinz=%list()>

dann kann man zum beispiel

  %<heinz[0]=gringo>

machen. bei hashes funkts natuerlich genauso. das ganze kann man jetzt
natuerlich verschachteln, zum beispiel mit

  %<heinz[1]=%hash()>
  %<heinz[1]{blede}=sau>

skulge?

** anlegen von makros

ich hab mir folgendes ueberlegt: da man datenstrukturen ja jetzt
beliebig verschachteln kann, sollte man auch makros zum beispiel in
hashes speichern koennen. mit dem momentanen %define kann man aber nur
top-level makros machen. ich koennt natuerlich ins %define einbauen,
dass es auch hashes und lists parsen kann, aber das waer erstens viel
arbeit und zweitens nicht einheitlich. aus dem grund schlag ich vor,
ein %lambda built-in zu machen, das ein makro zurueckliefert. dann
koennt man sagen

  %<heinz[1]{deinz}=%lambda(a,der %a is a trottl)>

wenn ma dann

  %<heinz[1]{deinz}(schani)>

macht, kommt raus

  der schani is a trottl

natuerlich wuerd ich das %define aus kompatibilitaets und convenience
gruenden lassen.

* schani, 14.12.1997, kurz nach mitternacht

** erfolgsmeldung

folgendes geht schon:

  %<heinz=%list()>
  %<heinz[0]=%list()>
  %<heinz[0][0]=deinz>
  %<heinz[0][0]>

ergibt

  deinz

*** ergaenzung vom 21.12.1997

jetzt kann man natuerlich statt den ersten drei zeilen schreiben

  %<heinz=%list(%list(deinz))>

* schani, 14.12.1997, nachmittag

** internals

ich bin nicht ganz gluecklich ueber die internals, weil sie im neuen
typsystem eigentlich eine ausnahme darstellen. wenn man eine list
zuweist, mit %<xyz=%list()> dann wird das symbol xyz mit der neuen
list belegt. wenn aber xyz ein internal waere, wuerde die set-methode
aufgerufen. irdendwie muss ich mir da noch was besseres einfallen
lassen.

** weitere erfolgsmeldung

ich hab jetzt schon fast alles aufs neue system umgestellt und die
regress-tests laufen schon wieder. ein paar kleine sachen hab ich
nur aendern muessen (initialisierung von hashes und lists halt).

** tautogen geht auch schon wieder

mit ein paar aenderungen, die die neuen datenstrukturen nuetzen
funkt der tautogen auch schon.

* schani, 17.12.1997, nachmittag

** list-builtins

ich hab jetzt die builtins fuer die lists auf das neue system
umgestellt.  konkret heisst das, dass die builtins, die frueher
listennamen als parameter nahmen, jetzt die listen selber
nehmen. ausserdem ist es jetzt so, dass die builtins, die frueher
listen erzeugt oder modifiziert haben, diese jetzt
zurueckgeben. betroffen sind:

     alt                          neu
  %arrlength(list)             %listlength(%list)
  %split(%str,%regex,list)     %<list=%split(%str,%regex)>
  %sort(list)                  %<list=%sort(%list)>
  %append(list,%str)           %<list=%append(%list,%str)>
  %uniq(list)                  %<list=%uniq(%list)>

fallst es noch nicht checkt hast: parameter werden immer call-by-value
uebergeben.

* schani, 19.12.1997, vor mittanacht

** list- und hash-builtins

ich hab noch die folgenden list- und hash-builtins auf das neue system
konvertiert:

     alt                          neu
  %ifdefkey(hash,key,x,y)      %ifdefkey(%hash,key,x,y)
  %foreach(var,list,stmt)      %foreach(var,%list,stmt)
  %foreachkey(var,hash,stmt)   %foreachkey(var,%hash,stmt)

** hashcount und keys

es gibt zwei neue builtins. %hashcount(%hash) gibt die anzahl der
key/value-paare in %hash zurueck. %keys(%hash) gibt eine list mit
allen keys aus %hash zurueck. diese ist ueblicherweise nicht sortiert.

** syntaxerweiterung

ich hab mir heute vorm einschlafen, als ich noch U2 hoerte, ueberlegt,
ob es nicht schlau waere, folgende erweiterung zur syntax
hinzuzufuegen:

  %<(expr)[3]>

evaluiert zuerst expr und wendet anschliessend den rest auf den
zurueckgelieferten wert an. so gaebe zum beispiel

  %<(%sort(%keys(%hash)))[0]>

den ersten key aus dem hash %hash aus. bis jetzt gibts nur eine
moeglichkeit, sowas zu tun, und die gefallen mir ueberhaupt nicht:

  %<temp=%sort(%keys(%hash))>%temp[0]

coolerweise ist die implementierung von dem ding eigentlich trivial,
aus dem grund werd ichs gleich ausprobieren.

*** habs gschrieben

scheint auch zu funken.

* schani, 21.12.1997, um zwaa in da frua

** list und hash

die makros list und hash hab ich jetzt so erweitert, dass man auch
vorinitialisierte listen und hashes zuweisen kann. zum bleistift:

  %<(%list(null,aans,zwaa))[1]>

gibt

  aans

kleines detail: eine list mit null elementen erzeugt man mit %list()
oder zb mit %list( ). eine list mit einem element, welches der
leerstring ist, erzeugt man mit %list(%""). eh kloa.

mit hash verhaelt sichs so, dass jeweils zwei argumente ein
key/value-paar bilden.

  %<(%hash(heinzi,deinzi,schani,banani)){heinzi}>

ergibt

  deinzi

** encode

ich hab ein makro namens encode geschrieben, welches ein beliebiges
value so in einen string umwandelt, dass dieser, wenn er evaluated wird,
wieder das value selbst ergibt. beispiel:

  %encode(%list(heinz,%hash(1,"a",2,b)))

ergibt

  %list(%"heinz",%hash(%"2",%"b",%"1",%"\"a\""))

der grund warum ich die scheisse mach is der, dass ich den chpp besser
frueher als spaeter zum kurden von cgi-skripts erweitern will.  damit
ich values von einer inkarnation des skripts zur naechsten
transportieren kann, brauch ich sowas, was dann die values in einem
hidden form-field versteckt. damit das am besten kurdet, braeuchten
wir noch einen komprimierungsalgorithmus (damits kleiner wird), einen
verschluesselungsalgorithmus (damits keiner mehr lesen oder aendern
kann) und einen entkurdifizieralgorithmus (so wie uuen/decode, damit
mans in das formfield schmeissen kann). die komprimierung koemma
hoffentlich ausm gzip klauen, die verschluesselung vom mac sein rc5
(das waer dann das erste, was sein leben auf dieser erde rechtfertigt
:-) ), das ich dann aber auf c zurueckkonvertieren muss, und fuer die
entkurdifizierung denk ich mir scho was aus.

* schani, 21.12.1997, nachmittag

** binaerdaten

wir sollten unsere routinen danach abchecken, dass sie auch das
nullbyte in strings erlauben. dann koennen wir auch binaerdaten
handeln (oder nach edvz-diktion: haendeln).

** unicode

irgendwann koemma unseren code dann so sichern, dass wir auch
unicode-input behandeln koennen. ich sollt sowieso ein typedef
chppChar oder so einfuehren, damit ich auf das vorbereite.

** dokumentation

ich hab angefangen, eine doc zum chpp zu schreiben. titel: chpp -
tutorial and reference. ich schreibs in Texinfo, weil mir das als
schlauestes Format erscheint, da mans erstens zu huebschem
ausgedruckten text, zu info files und zu html machen kann und
zweitens, weils eh dodlsicher (also fast tuttensicher) is. zu finden
im verzeichnis doc.

* schani, 25.12.1997, abend

** join

hab ein neues makro gemacht: join haengt eine liste zusammen. zwischen
jeweils zwei elements hauts einen string rein. also zum beispiel:

  %join(ixi,%list(axi,kraxi,huehnerhaxi))

ergibt

  axiixikraxiixihuehnerhaxi

** mainfilename

ich hab eine globale variable namens mainfilename reingehaut, die den
namen des hauptfiles angibt, das gerade chakotayt wird.

* schani, 24.1.1998, nachmittag

** depend

neues makro namens depend, welches im dependency generation modus das
argument als dependency angibt, ansonsten nichts tut.

** schreiben in files

mittlerweile nimmt open einen optionalen zweiten parameter, der entweder
'r' oder 'w' sein kann. 'r' ist lesen (default) und 'w' schreiben. in ein
mit 'w' geoffnetes file kann man mit write schreiben, also

  %<file=%open(xyz.txt,w)>
  %write(%file,heinzi deinzi%"\n")
  %close(%file)

** fileops beginnen jetzt alle mit f

das heisst fopen, freadline, fclose, feof, fpipe, fwrite

** fstat

implementiert.

* schani, 5.2.1998, nachmittag

** garbage collection

ich hab jetzt die garbage collection eingebaut. der collector ist im
verzeichnis gc. konkret heisst das, dass man keinen speicher mehr
freigeben muss, weil das automatisch geschicht. um speicher zu
allokieren ist der header memory.h zu inkludieren. folgende funktionen
stehen dann zur verfuegung:

  void* memAlloc(int numBytes);
  void* memAllocAtomic(int numBytes);
  void* memRealloc (void *object, int numBytes);
  void* memXAlloc (int numBytes);
  void* memXAllocAtomic (int numBytes);
  void* memXRealloc (void *object, int numBytes);

funktionen funken wie gewohnt. die X funktionen stellen auch sicher,
dass das allokieren nicht fehlschlaegt, i.e. rauchen ab, wenn kein
speicher mehr da ist.

bitte die X funktionen verwenden, ausser wenns WIRKLICH nicht anders
geht.

* schani, 9.2.1998, kurz nach mittanacht

** lambda tut funken

das hier:

  %<l=%lambda(a,%lambda(b,%a%b%a))>\
  %<x=%l(-)>\
  %x(a)

ergibt das:

  -a-

skullge?

* schani, 10.2.1998, nachmittag

** theoretisch fertig min umbau

soda. bis auf a paar kleine sachen bin ich fertig min umbau vom
chpp. der meiste code sollte unmodifiziert weiterfunken. das was nicht
weiterfunkt hat dann mit dem lexikalischen scoping zu tun. alles in
allem ist der chpp schneller geworden. um wieviel haengt von der
anwendung ab. der tautogen zum beispiel ist fast gleichgeblieben. das
ausrechen von den results vom letzten se-semester laeuft fuenfmal so
schnell.

* schani, 11.2.1998, kurz nach mitternacht

** docs zu referenzen

mit den referenzen ist das folgendermassen: wenn man eine variable
dereferenziert wird sie standardmaessig kopiert, i.e.

  %<x=%y>

macht eine kopie von y und speichert sie in x. um das zu verhindern,
gibts das kurden-b, welches man vor den variablennamen schreibt, also
z.b

  %<x=%&y>

oder auch

  %<x=%<&y>>

um zyklische refernzen brauchst dir keine gedanken zu machen, fuer was
gibts die gc? das ganze funkt natuerlich auch bei listen usw, also

  %<x[3]=%&y>

geht a. sogar

  %<x[3]=%&x>

in so einem fall wuerd ich x allerdings lieber ned encoden
:-). ausserdem gibts noch ein weiteres feature. angenommen du machst:

  %<y=abc>
  %<x=%&y>
  %<x=123>

dann ist x natuerlich 123, y aber immer noch abc. das ist deswegen,
weil das assignment nicht den wert ueberschreibt sondern einfach einen
neuen pointer zuweist, aber:

  %<y=abc>
  %<x=%&y>
  %<&x=123>

jetzt ist auch y gleich 123. skullge?

der returnwert von einem makro wird nicht noch zusaetzlich
kopiert. ergo, wenn

  %define(self,a,%&a)

ist, dann gibt

  %self(%x)

eine kopie von x zurueck, weil x ja beim makroaufruf kopiert wurde,
aber

  %self(%&x)

gibt x selbst zurueck.

wie ich dir uebrigens auch schon gesagt habe, werden bei aufrufen von
builtins wirklich nur dann kopien angelegt, wenn wirklich noetig, also

  %listlength(%l)

legt nicht wirklich eine kopie von l an, weils ja die uebergebene
liste nicht veraendert.

btw: alle kopien sind deep copies, i.e. %x macht eine deep copy von x.
ich bin nicht vollkommen gluecklich mit der loesung. die ist eher ein
erbstueck von frueher, als alles noch mit kopien gemacht
wurde. vermutlich waers besser, wenn wir shallow copies machen und ein
%copy makro machen, das deep copied oder so. insbesondere heisst deep
copy auch, dass du keine datenstruktur normal dereferenzieren kannst,
die eine referenz auch sich selbst enthaelt, weil das zu einer
endlosschleife fuehrt... wie gesagt, da muessma noch drueber reden,
mir taugts auch ned wirklich.

** ad scoping

wie bereits erwaehnt hab ich das scoping von dynamischem auf
lexikalisches scoping umgestellt, d.h. es ist jetzt so wie in C: ein
makro kann lokale variablen haben (schliesst parameter ein), diese
sind jedoch in von diesem makro aufgerufenen makros nicht
sichtbar. ausserdem gibts lambda makros, welche diese schema ein wenig
erweitern, was ich oben eh schon demonstriert habe. ich hoff, du
checkst es. wenn nicht, erklaer ichs dir am montag. oder du fragst den
schalli was das environmental model of execution is.

variablen, welche du in einem makro definierst und die nicht lokale
variablen sind, werden im globalen scope definiert, also so wie
frueher. z.b.

  %define(abc,a,%<x=%a>)
  %abc(123)

dann ist x eine globale variable mit dem wert 123. eh klar. locals
funkt so wie frueher, i.e.

  %define(abc,a,%locals(x,%<x=%a>))
  %abc(123)

1000 mal %abc probiert, 1000 mal is nix passiert. 1000 und eine nacht
und ... naja :-)

** von wegen eatUntil und so...

mein teil funkt jetzt so: anstatt den code direkt vom string weg zu
parsen und dabei auszufuehren hab ich das jetzt in zwei teile
getrennt: zuerst wird der string geparsed. dabei wird sogenannter
bytecode erzeugt. dieser bytecode kann dann entweder sofort
ausgefuehrt werden oder man kann ihn speichern (zum beispiel fuer a
lambda oder define). vorteile sind: es ist schneller, die beiden teile
sind einfacher und dadurch leichter zu warten, einmal geparster code
ist metachar unabhaengig, man koennte bytecode theoretisch in ein file
abspeichern (i.e. precompiled headers, welche dann natuerlich meta-
und command-char unabhaengig sind).

aus der ganzen scheisse folgt, dass es kein eatUntil mehr gibt, weil
ich es nicht mehr brauche und fuer deine zwecke wars eigentlich eh ned
des richtige. sowas wirst du dir selber schreiben muessen. sollte ned
viel mehr als fuenf zeilen sein.

was das eval angeht steht die sache anders. soweit ich gesehen habe
verwendest du eigentlich eh nur evalDS, was einen dynstring in einen
dynstring evaluiert. dasselbe was

  eds = evalDS(&ds);

gemacht hat, geht jetzt folgendermassen:

  eds = dsNew();
  parParseUntil(inputNewDynstring(&ds, 0), 0,
                bcwNewOutput(globalEnvironment, owNewDynstring(&eds)));

jaja, ich weiss. schreibst dir halt eine funktion dafuer. zur
erklaerung: der parser liest von einem inputReader und schreibt auf
einen bytecodeWriter. man kann einen inputReader erzeugen, der von
einem dynstring liest (inputNewDynstring). dann erzeugt man einen
bytecodeWriter, der den bytecode nicht irgendwo aufhebt, sondern ihn
gleich ausfuehrt, und zwar in einen outputWriter (bcwNewOutput). jetzt
braucht man nur mehr einen outputWriter, der in einen dynstring
schreibt (owNewDynstring). jaja, danke, danke, ich weiss ich bin
genial. nein, du musst dich nicht unbedingt verbeugen. ;-)

ich hoffe, das reicht dir, um die commands wieder instand zu
setzen. ich hab einfach das definen der commands im filler.c
auskommentiert. ausserdem musst dann noch das commands.o in die
objects im Makefile.common rein.

symtab.h und macros.h gibts natuerlich nimmer. der oben beschriebene
dreck ist in parser.h, bytecode.h, bcoutput.h, input.h und output.h
drin.

** definieren von variablen und makros

das definieren geht jetzt nimmer mit defineGlobal... sondern mit
envAddBinding(). als ersten parameter gibst am besten 0 an, dann nimmt
er den globalen namespace. der zweite parameter ist der name der
variable oder des makros und der dritte parameter ist der wert, also
der inhalt der variable oder das makro. einen solchen wert kannst dir
mit den valueNew... funktionen erzeugen (value.h). zum beispiel
valueNewScalar(&ds). fuer makros musst valueNewLambda() verwenden.
als environment musst du valueNewLambda() die globale variable
globalEnvironment (in environment.h) angeben. wenn keine varargs sind,
gib als minVarArgs und maxVarArgs 0 an. als metaChar gib im moment
einfach mal '%' an. ich muss mir da noch was ueberlegen. als code
musst den bytecode angeben, den der parser (eigentlich der
bytecodeWriter) erzeugt hat. du kannst aus einem dynstring ds
folgendermassen bytecode erzeugen:

  bc = parParseIntoBCUntil(inputNewDynstring(&ds, 0), 0, 1);

** append

append funkt jetzt so: uebergeben musst du als ersten parameter eine
referenz auf eine list, als zweiten den wert, den du anhaengen willst,
also

  %append(%&l,123)

zurueckgeben tuts gar nix.

** naming conventions

ich hab noch keine namen von builtins veraendert. ich denke, das
sollten wir am montag in ruhe und gemeinsam erarbeiten. wenn du es
wirklich eilig hast, kannst es ja selben aendern. das einzige, was du
machen musst ist, im jeweiligen file im builtins/ verzeichnis ganz
unten den string im registerBuiltIn() aufruf zu aendern.

* schani, 11.2.1998, nachmittag

** env

es gibt jetzt ein internal namens env, welches alle
environmentvariablen enthaelt. funkt wie ein hash.

* schani, 12.2.1998, nachmittag

** makros mit 0 parameters

gibts jetzt. zum beispiel:

  %define(newcounter,%locals(n,%<n=0>%lambda(%<n=%[n+1]>%n)))
  %<counter=%newcounter()>
  %counter() %counter() %counter()

gibt

  1 2 3

* schani, 13.2.1998, in da fruehen frueh

** ideen zum parsen

ich hab mir jetzt eingehend ueberlegt, wie ich bessere und sinnvollere
fehlermeldungen machen kann, insbesondere bei variablen, die nicht
bekannt sind. ein nebeneffekt der parsing/execution trennung ist der,
dass ich verwendungen von undefinierten variablen fast zur gaenze
schon zu parse-zeiten erkennen und melden kann, und zwar an der stelle
im quellcode, wo sie auftreten und nicht dort, wo das makro aufgerufen
wird, das sie verwendet. allerdings kann der prozess teilweise
laenglich werden, was aber andererseits eh wurscht ist, weil man ja,
wenn ich das implementiere, und frueher oder spaeter werd ich das
wohl, eh alles precompilen wird koennen, wos auf geschwindigkeit
ankommt.

so, jetzt muss i die scheisse nur mehr schreiben.

* schani, 14.2.1998, abend

** fehlermeldungen beim parsen

ich hab die scheisse jetzt implementiert und es scheint ganz gut zu
funken. wenn er merkt, dass eine variable accessed wird, die zur
ausfuehrungszeit wahrscheinlich (garantieren kann mans nicht) nicht
existiert, gibt er ein warning aus.

** match

match funkt jetzt bisserl anders. anstatt die matches in die variablen
%0, %1, ... zu schreiben, nimmt er jetzt optional ein drittes
argument, welches eine refenz auf eine list sein muss. deren inhalt
loescht er und schreibt dort die matches rein, i.e. element 0 ist dann
der ganze match, 1 der erste submatch etc.

* schani, 22.2.1998, nachmittag

** lsort

das lsort funkt jetzt bissal anders: es nimmt jetzt als zweiten
parameter ein makro, das die sort-order angibt, also zwei parameter
nimmt und einen int zurueckgibt, der bestimmt, welcher der beiden
kleiner ist, oder obs gleich sind, also so wie strcmp(3). gibt man als
zweiten parameter das builtin scmp an, funkts wie bisher. wenn man zum
beispiel die sortierordnung umdrehen will, geht folgendes:

  %lsort(%thelist,%lambda(a,b,%[-%scmp(%a,%b)]))

skullge?

** and, or und not

es gibt drei neue built-ins namens and, or und not. and und or nehmen
beliebig viele parameter und evaluieren diese von links nach rechts,
bis sie zum ersten kommen, der false (and) oder true (or) ist. in
diesem fall wird dann dieser wert zurueckgegeben. wenn keine parameter
uebergeben werden, gibt and true zurueck, or false. not ist
offensichtlich.

** list.chh

im include-file list.chh gibts ein listSearch makro. erster parameter
ist eine liste, zweiter eine closure, welche ein argument nimmt und
einen booleschen wert liefert. listSearch gibt den index des ersten
elements in der liste zurueck, fuer das die closure true liefert, oder
-1 falls sie das bei keinem element tut. um zum beispiel ein bestimmtes
element zu finden, kann man folgendes machen:

  %listSearch(%list(a,b,c),%lambda(p,%seq(%p,b)))

gibt

  1

zurueck.

** sgsub

ich hab jetzt das sgsub so erweitert, dass man als ersetzung nicht nur
einen normalen string angeben kann, sondern auch eine closure mit
einem argument, die die liste der registers uebergeben bekommt und die
ersetzung zurueckliefert. so ergibt zum beispiel das:

  %sgsub(abaabaaa,a+,%lambda(r,%slength(%r[0])))

das:

  1b2b3

bist du deppat, der chakotay ruled!!!! das soll ma da joe amal in
webobjects zeigen.

** cond

neues makro namens cond: funkt so wie in scheme, also nimmt immer
paare von expressions und evaluated die erste. wenn die true ergibt
wird die zweite evaluiert und dann das ganze beendet. is also
sozusagen ein if mit beliebig vielen else-ifs. zum beispiel:

  %cond(0,a,
        1,b,
        2,c)

ergibt

  b

weil 1 der erste ausdruck ist, der true ist.

* schani, 25.2.1998, nach mitternacht

** apply

neues makro namens apply. nimmt zwei parameter. erster ist ein makro,
zweiter eine liste.  ruft das makro mit den elementen der liste als
parameter auf.

** listMap

in list.chh gibts jetzt ein makro namens listMap, welches zwei
parameter nimmt, naemlich eine closure, die einen parameter nimmt und
eine liste. listMap generiert eine neue liste, indem sie die closure
fuer jedes element der alten liste aufruft und die ergebnisse in die
neue haut. beispiel:

  %encode(%listMap(%lambda(a,%slength(%a)),%list(a,ab,abc)))

ergibt

  %list(%"1",%"2",%"3")

*** listMap die zweite

ich habs jetzt erweitert. das makro darf beliebig viele parameter
nehmen, dafuer muss man dann auch genausoviele listen uebergeben. um
zum beispiel die elemente von jeweils zwei listen zu addieren, macht
man folgendes:

  %encode(%listMap(%lambda(a,b,%[a+b]),%list(1,2,3),%list(4,5,6)))

ergibt

  %list(%"5",%"7",%"9")

rule i oder ned?

* schani, 26.2.1998, nachmittag

** lsort und luniq

lsort hab ich jetzt so umgeschrieben, dass der zweiter parameter
optional ist. wenn man ihn nicht angibt, wird statt dessen scmp
verwendet. luniq arbeitet jetzt auch so. wird kein zweiter parameter
angegeben, verwendet es seq.

** typeof

neues makro namens typeof. gibt den typ eines werts zurueck, zum
bleistift list, hash, scalar, ...

* schani, 27.2.1998, nach mitternacht

** case

jetzt gibts auch ein case. erster parameter ist ein string, dann kommt
in zweierpaaren immer eine liste aus strings und eine expression. wenn
der string in der liste der strings vorkommt, wird die jeweilige
expression ausgefuehrt und das ganze beendet. wird statt der liste der
string else angegeben, dann wird auf jeden fall dessen expression
ausgefuert. zum bleistift:

  %case(%number,
        %list(2,3,5,7,11),a klaane primzoi,
        %list(1,4,6,8,9,10),ka klaane primzoi,
        else,wos waas denn i
  )

alles klar, herr kommissar?

** lappend

bei lappend kann man jetzt nicht nur einen anzuhaengenden wert
uebergeben, sondern beliebig viele.

* schani, 27.2.1998, nachmittag

** equal und same

ich hab zwei neue makros gemacht. same checkt, ob zwei werte dieselben
sind und equal checkt, ob zwei werte gleich sind. beide sind auf jede
art von wert anzuwenden, ergo auch auf strings, was wiederum seq
unnoetig macht, weil es eine untermenge von equal ist. aus diesem
grund gibts es nicht mehr. beispiele:

  %<lst1=%list(a,b,c)>\
  %<lst2=%list(a,b,c)>\
  %equal(%lst1,%lst2)
  %same(%lst1,%lst2)
  %same(%lst1,%lst1)
  %same(%&lst1,%&lst1)

ergibt

  1
  0
  0
  1

* schani, 28.2.1998, nach mitternacht

** listIndexOf

im list.chh gibts jetzt ein makro listIndexOf. nimmt als ersten
parameter eine liste und als zweiten parameter irgendwas. gibt den
index des ersten elements in der liste zurueck, der equal zu dem
irgendwas ist. gibt -1 zurueck, wenns keinen gibt.

* schani, 6.4.1998, nachmittag

** linsert

es gibt jetzt ein makro linsert mit dem man ein element in eine liste
einfuegen kann. parameter sind: eine referenz auf eine liste, der
index des elements vor das das neue eingefuegt werden soll und das
neue element.

  %<lst=%list(a,b,c)>%linsert(%&lst,1,x)%encode(%lst)

ergibt

  %list(%"a",%"x",%"b",%"c")

** ldelete

ldelete loescht ein element aus einer liste. beispiel:

  %<lst=%list(a,b,c)>%ldelete(%&lst,1)%encode(%lst)

ergibt

  %list(%"a",%"c")

* schani, 7.4.1998, nach mittanacht

** argumentreihenfolgen

ich hab jetzt der konsistenz halber die argumentreihenfolgen einiger
makros geandert. konvention ist die folgende: argumente sind in der
reihenfolge anzugeben, die der chpp-syntax entsprechen, natuerlich nur
von einem hoeheren level betrachtet. wenn ich zum beispiel ein makro
hab, das ein element in eine list einfuegt, so kann man meta-chpp'isch
dem die syntax %<lst[index]=elem> geben, ergo erster parameter liste,
zweiter index, dritter element. fuer ein makro, welches ein anderes
makro (closure) auf alle elemente einer liste anwendet (map), wuerde
die syntax so ausschaun: %macro(%lst), also zuerst makro, dann
liste. das suchen nach einer regexp sehe ich auch als anwenden eines
makros an, ergo hat sgsub die metasyntax %<regex(%string)=%repl>, also
zuerst regex, dann string, dann replacement. optionale parameter
stehen immer hinten.

aendern muessen hab ich die reihenfolge bei den makros ssplit, sgsub,
ssub.

* schani, 8.4.1998, nachmittag

** stokenize

neues makro: stokenize. nimmt eine regexp und einen strings. erzeugt
daraus eine liste aller substrings aus dem string, die die regexp matchen.
bsp: aus

  %encode(%stokenize([a-zA-Z0-9]+,%" a bc d04 d   fsfd, rwe"))

wird

  %list(%"a",%"bc",%"d04",%"d",%"fsfd",%"rwe")

als dritten parameter kann man eine closure angeben, die fuer jeden
match mit der register-liste als parameter aufgerufen wird, und die
das zurueckgibt, was dann in die liste reinkommen soll.

* schani, 9.4.1998, abend

** hcontains und ifdefkey

ich hab jetzt ein neues makro namens hcontains gemacht, dass als
parameter einen hash und einen string nimmt, und zurueckgibt, ob der
string als key in dem hash drin ist. dadurch wird ifdefkey unnoetig
und fliegt raus. mit anderen worten: was frueher so war

  %ifdefkey(%hash,%key,heinz,deinz)

wird jetzt

  %if(%hcontains(%hash,%key),heinz,deinz)

** bound und ifdef

gleiches schicksal erleidet ifdef. das makro bound gibt zurueck, ob im
aktuellen environment der angegebene name gebunden ist. in anderen
worten: was einmal

  %ifdef(%name,heinz,deinz)

wird jetzt

  %if(%bound(%name),heinz,deinz)

* schani, 14.4.1998, nachmittag

** sgsub

sgsub hat jetzt einen optionalen vierten parameter, der ein
optionsstring ist.  im moment gibts nur eine option, naemlich 'i', was
soviel heisst wie case-insensitive match.

  %sgsub(it,SHIT on It!,%lambda(r,*%r[0]*),i)

evaluated zu

  SH*IT* on *It*!

* schani, 30.4.1998, nachmittag

** cvs

cvs tut laufen. zumindest behauptet das der murman. man muss sich
einloggen mit

	cvs login

wobei CVSROOT gesetzt ist auf

	:pserver:heinz@mondoshawan.ml.org:/cvshome/chpp

dann

	cvs checkout

den rest im cvs manual lesen.

* murman, 4.5.1998, nachm aufstehen aber vorm schlafengehn

** fopen, fpipe

bei fopen gibts jetz auch mode a - damit man was anhaengen kann an a
file fpipe hat vorn an neuen parameter, der bestimmt obs a reading
oder a writing pipe is:

  %fpipe(r, /bin/sh, -c, ls)
  %fpipe(w, /usr/sbin/sendmail,philipp)

damit is der chpp scho viel mehr cgi-tauglich...

* schani, 6.5.1998, vorm aufstehen aber nachm schlafengehn :-)

** priorities

ich hab im TODO file meine prioritaeten fuer die naechsten aenderungen
am chpp zusammengschrieben. wenn noch wem was einfaellt, moege er das
auch reinschreim. als ich mir dann die prioritaeten so ansah, hab ich
beschlossen, ein paar wochen (naja, vielleicht auch nur ein paar tage)
chpp abstinenz zu machen, weil mein lieblingspunkt (chpp schneller
machen) kommt leider erst an vierten stelle :-(.

* schani, 14.5.1998, nachmittag

** fgetwd und fchdir

sind hoffe ich selbsterklaerend.

* schani, 25.5.1998, ur fruah

** autoconf

ich hab die ganze configuration auf autoconf und automake umgestellt.
funktionieren sollte autoconf 2.12 und automake 1.3. nach dem
auschecken einfach

  aclocal
  autoheader
  automake
  autoconf

machen. dann hat man ein configure. das aufrufen und die scheisse
laeuft. wichtige targets sind dann

  make           eh klar
  clean          a klar
  distclean      raeumt auch alle makefiles und so weg
  install        klar
  dist           macht ein .tar.gz zum distributen. ur cool.

* schani, 12.6.1998, hehe

** srange und smap

srange macht einen string aus zwei chars indem er alle chars
dazwischen aneinanderhaengt. zb

  %srange(0,9)

gibt

  0123456789

und

  %srange(a,z,0,9)

gibt

  abcdefghijklmnopqrstuvwxyz0123456789

smap funkt wie tr. konvertiert die chars aus dem ersten parameter zu
den chars aus dem zweiter parameter. bsp:

  %smap(%srange(a,z),%srange(A,Z),Heinzi Deinzi)

gibt

  HEINZI DEINZI

* schani, 5.7.1998, kurz nachdem deutschland gegen kroatien abbissen hat

** return

es gibt ein makro namens return, welches ein makro einfach beendet.
parameter nimmts keinen, weil werte zurueckgeben kamma anders auch.
bleistift:

  %define(heinz,%for(i,0,9,%i%if(%[i==5],%return())))
  %heinz()

gibt

  012345

in naechster zeit kommt dann auch noch break und continue dazu.

* schani, 31. 9. 1998, nachmittag

** flock

flock lockt a file. erster parameter ist der filename. zweiter
optionaler parameter ist die lockoption:

  l      shared
  x      exclusive
  u      unlock
  n      non-blocking

wenn nix angegeben wird, ist x default.

* schani, 2. 10. 1998, nachmittag

** scrypt

scrypt macht a crypt. erster parameter key, zweiter salt.

* schani, 14. 11. 1998, nach babylon 5

** listSelect

in list.chh gibts a neues makro namens listSelect. als ersten
parameter nimmts eine closure, die einen parameter nehmen und einen
wahrheitswert zurueckgeben sollte. als zweiten parameter nimmts eine
liste. es gibt eine neue liste zurueck, die alle elemente vom zweiten
parameter enthaelt, fuer die die closure true zurueckgegeben hat. bsp:

  %encode(%listSelect(%lambda(e,%[e>4]),%list(1,2,3,4,5,6,5,4,3,2,1)))

gibt

  %list(%'5',%'6',%'5')

* schani, 20. 1. 1999, waehrend da jin tf trainiert

** fglob

es gibt a neues makro namens fglob. nimmt als parameter a filenamen
pattern (mit shell patterns). der wird dann geglobbed und zurueck
kommt a liste mit allen gematcheden filenamen. bsp:

  %foreach(fn,%fglob(*),do gibts a feil des haast %fn%'\n')

bei an fehler (zum bleistift ka match) kommt nix zrueck (i.e. man kann
den wahrheitswert checken).

* schani, 27. 1. 1999, kurz nachdem biffl ausm cslab kurdet is

** timeUNIX, timeUNIX2Hash, timeHash2UNIX, timeNow

lauta leiwande neue time makros. schon komplett dokumentiert. foi supa
im hirn geistiga natur.

* schani, 28. 1. 1999, zmittag

** lambdas encoden

man kann jetzt mit %encode auch lambdas encoden. beispiel:

  %encode(%lambda(a,%a ist ein kurde))

ergibt

  %lambda(%'a',%<%'a'>%' ist ein kurde')

* schani, 29. 1. 1999, waehrend simpsons

** let

es gibt jetzt a %let. funkt so wie let* in lisp. is schon dokumentiert.

** environments und eval

environments kann ma jetzt auch im chpp erzeugen und
verwalten. funktioniert so: in jedem evaluationskontext gibts ein
aktuelles environment (eh kloa). dieses kriegt ma mit %envThis().  mit
%envNew kann ma a neues environment erzeugen. wenn ma kan parameter
angibt, dann is es ein environment ohne parent, also voll nackat mit
uebahaupt nix drin (kane builtins, kane special forms, kane variablen,
ka gar nix). oder man gibt als parameter das parent-environment an.
mit %envAdd kann ma zu an environment a neues binding
hinzufuegen. erster parameter is das environment, zweiter der name des
bindings (variablenname) und dritter der wert.

dann gibts jetzt no a cooles builtin namens %eval. das uebernimmt die
funktion von %{}, obwohls das natuerlich immer no gibt, obwohl i
ueberleg es rauszukurden, weil mans eh ur selten braucht und dann
haetma a neue klammer frei (hehe). also %eval(heuslscheisse) is genau
dasselbe wie %{heuslscheisse}. dem eval kamma allerdings no als
zweiten parameter das environment angeben, in dem er die kurderei
evalen soll (standardmaessig natuerlich das aktuelle
environment). bleistift:

  %<e=%envNew(%envThis())>
  %envAdd(%e,a,heinz) 
  %eval(%'%a',%e)

gibt

  heinz

ma kann das recht cool brauchen zum passen von daten von cgi-skript
zum naechsten ohne sicherheitsluecke. wenn man jetzt einem cgi-skript
ein %encode'tes irgendwas als parameter gibt und das dann im skript
evaled, dann koennte ja der user so boese sein und statt dessen an
chpp-code uebergeben, der schlimme sachen macht. mit den environments
kann ma jetzt a umgebung zum evalen machen, wo nix passieren
kann. bsp:

  %<e=%envNew()>
  %envAdd(%e,list,%list)
  %envAdd(%e,hash,%hash)

wenn man jetzt einen string im environment e ausfuehrt, kann
ueberhaupt nix passieren, ausser dass vielleicht a paar listen und
hashes erzeugt werden, weil verwenden kamma dort nedamal a
%if. skulge?

* schani, 30. 1. 1999, ua frua

** defspecial

es gibt jetzt eine moeglichkeit wie man sich eigene special forms
definen kann. %defspecial funkt so wie %define nur dass beim aufruf
des makros die argumente nicht evaled werden, sondern dem makro als
bytecode uebergeben werden. diesen bytecode kann das makro dann nach
belieben evalen (mit %eval kloaraweis). ein zweita untaschied is, dass
das environment, in dem ein %defspecial'tes makro evaled wird ein
unter-environment vom environment is, aus dem aus es aufgerufen wird
und nicht dessen, in dem es %defspecial'ed wurde.

bsp:

  %defspecial(heusl,name,code,
      %for(%eval(%name),0,2,
          %eval(%code)
      )
  )
  %heusl(kurde,kurde is jetz %<kurde>%'\n')

gibt

  kurde is jetz 0
  kurde is jetz 1
  kurde is jetz 2

jetz fragst di sicher fuer was braucht ma den schas? sei dir
versichert: i heds ned implementiert wenn is ned braucht hed.

* schani, 3. 2. 1999, waehrend jin quaken tut

** hdelete

mit %hdelete kama keys aus an hash rausloeschen. is gedoced.

* schani, 4. 2. 1999

** release 0.3.5

it's a long way to 1.0

* schani, 7. 2. 1999, vorm mittagessen

** funlink, frmdir

name says it all (hoff i). is scho doced.

* schani, 12. 3. 1999, kuaz foa mittanacht

** idee(n)

i hab jetzt die idee, die alle probleme aus der welt schaffen wird
(hunger, krieg, windows, handys, ...). die sache ist eine
verallgemeinerung des aenderns des metachars. was ich moeglich machen
will ist folgendes:

man soll jeder beliebigen zeichenkette eine chpp-bedeutung geben
koennen. beispiele fuer chpp-bedeutungen sind: meta-char, oeffnende
und schliessende klammer bei makro-aufrufen, argumenttrenner fuer
makroaufrufe...

ich stell mir das in etwa so vor: ich will zum bleistift, dass ab
jetzt der string ||| auch meta-char wird:

  %defstring(|||,metachar)

und dann will ich dass % nicht mehr meta-char ist:

  %undefstring(%%)

dann will ich noch kurden, dass jeder beliebige string auch als
makro-aufruf (mit null argumenten) agieren kann. dann kann ich mir im
parser zum beispiel den special case von metachar-quoting ersparen (%%
ergibt %) indem ich definiere:

  %defstring(%'%%',macro,%'%')

skullge? aber es kommt no besser: wenn i zum beispiel den chpp nur
dazu verwenden will, html kommentare zu entfernen und keine
macro-expansion zu machen, kann i folgendes machen:

  %defstring(<!--,macro,%outputenable(0))
  %defstring(-->,macro,%outputenable(1))
  %undefstring(%%)

oder i kann c-style kommentare fuern chpp machen:

  %defstring(/*,macro,%outputenable(0))
  %defstring(*/,macro,%outputenable(1))

packst es? mit klammern soll das in etwa so funken:

  %defparens(%'(<',%'>)',macroargs)

dann koennte man makros wahlweise mit ( ) oder mit (< >)
aufrufen. letzteres hat kloaraweis den vorteil, dass man dann in den
macro-argumenten die normalen klammern ganz unbefangen verwenden kann
ohne quoten zu muessen. man koennt dann auch zum bleistift die %{} und
%[] klammern im chpp selbst definen:

  %defparens([,],macro,%arith)
  %defparens({,},macro,%eval)

um nochamal zu den c-style kommentaren zurueckzukommen: natuerlich
rulen die ned so wie is oben aufgschriem hab, weil natuerlich der code
zwischen /* und */ seiteneffekte haben kann. aus diesem grund (und
anderen) wird ma si a klammern definen koennen, die ohne metachar
funken und einfach ein makro oder a special form aufrufen:

  %defspecial(comment,c,)
  %defparens(/*,*/,call,%comment)

das heisst, jedes mal wenn ma schreibt /* scheisse */ dann wird das
comment special form aufgerufen (argumente von special forms werden
nicht evaluiert) und das tut genau nix. skullge? mit dem feature kann
ma dann zum bleistift ur cool html preprocessen indem ma defined

  %defparens(<,>,call,%mytagprocessor)

wenn i also schreib

  <heusl> </kurde>

dann wird daraus eigentlich

  %mytagprocessor(heusl) %mytagprocessor(/kurde)

ein paar dinge muss i ma no uebalegn, zum bleistift wie das mit
whitespace bei den parametern fuer diese dinger ist usw. 

das coole bei der sache ist ausserdem, dass es nur die komplexitaet
vom parser vergroessert und ansonsten keinerlei auswirkungen hat. das
heisst, wenn ich dann einmal einbau, dass ma bytecode in a file
schreiben kann, hat man keinerlei nachteil.

* schani, 13. 3. 1999, nachm mittagessen

** --command-char, --meta-char

es gibt jetzt zwei command line options mit denen man command und meta
char aendern kann.

** metachar, quotechar

mit den variablen metachar und quotechar kamma jetzt den meta char und
den quote char abfragen und aendern. zb

  %<metachar=&>
  %des %is %ka %makro &<makro=oba des scho>&makro

gibt

    %des %is %ka %makro oba des scho

** break

break funkt jetzt auf ganzer linie. zb:

  %foreach(heusl,%list(a,b,c,d),%if(%equal(%heusl,c),%break(),%heusl))

gibt

  ab

man kann auch ein numerisches argument angeben, das bestimmt aus
wievielen schleifen ausgebrochen wird. 0 steigt nur aus der innersten
aus, 1 aus den innersten zwei usw. aus zu vielen schleifen
auszubrechen ist natuerlich nicht erlaubt.
